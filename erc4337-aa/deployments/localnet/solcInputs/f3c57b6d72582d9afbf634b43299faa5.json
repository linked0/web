{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"./ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address implementation, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1822Proxiable} from \"../../interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Not enough balance for performing a CREATE2 deploy.\n     */\n    error Create2InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error Create2FailedDeployment();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Create2InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        if (addr == address(0)) {\n            revert Create2FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IPeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/core/BaseAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-empty-blocks */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"./Helpers.sol\";\nimport \"./UserOperationLib.sol\";\n\n/**\n * Basic account implementation.\n * This contract provides the basic logic for implementing the IAccount interface - validateUserOp\n * Specific account implementation should inherit it and provide the account-specific logic.\n */\nabstract contract BaseAccount is IAccount {\n    using UserOperationLib for PackedUserOperation;\n\n    /**\n     * Return value in case of signature failure, with no time-range.\n     * Equivalent to _packValidationData(true,0,0).\n     */\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * Return the account nonce.\n     * This method returns the next sequential nonce.\n     * For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\n     */\n    function getNonce() public view virtual returns (uint256) {\n        return entryPoint().getNonce(address(this), 0);\n    }\n\n    /**\n     * Return the entryPoint used by this account.\n     * Subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * Validate user's signature and nonce.\n     * Subclass doesn't need to override this method. Instead,\n     * it should override the specific internal validation methods.\n     * @param userOp              - The user operation to validate.\n     * @param userOpHash          - The hash of the user operation.\n     * @param missingAccountFunds - The amount of funds missing from the account\n     *                              to pay for the user operation.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external virtual override returns (uint256 validationData) {\n        _requireFromEntryPoint();\n        validationData = _validateSignature(userOp, userOpHash);\n        _validateNonce(userOp.nonce);\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * Ensure the request comes from the known entrypoint.\n     */\n    function _requireFromEntryPoint() internal view virtual {\n        require(\n            msg.sender == address(entryPoint()),\n            \"account: not from EntryPoint\"\n        );\n    }\n\n    /**\n     * Validate the signature is valid for this message.\n     * @param userOp          - Validate the userOp.signature field.\n     * @param userOpHash      - Convenient field: the hash of the request, to check the signature against.\n     *                          (also hashes the entrypoint and chain id)\n     * @return validationData - Signature and time-range of this operation.\n     *                          <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                              otherwise, an address of an \"authorizer\" contract.\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *                          <6-byte> validAfter - first timestamp this operation is valid\n     *                          If the account doesn't use time-range, it is enough to return\n     *                          SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function _validateSignature(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    ) internal virtual returns (uint256 validationData);\n\n    /**\n     * Validate the nonce of the UserOperation.\n     * This method may validate the nonce requirement of this account.\n     * e.g.\n     * To limit the nonce to use sequenced UserOps only (no \"out of order\" UserOps):\n     *      `require(nonce < type(uint64).max)`\n     * For a hypothetical account that *requires* the nonce to be out-of-order:\n     *      `require(nonce & type(uint64).max == 0)`\n     *\n     * The actual nonce uniqueness is managed by the EntryPoint, and thus no other\n     * action is needed by the account itself.\n     *\n     * @param nonce to validate\n     *\n     * solhint-disable-next-line no-empty-blocks\n     */\n    function _validateNonce(uint256 nonce) internal view virtual {\n    }\n\n    /**\n     * Sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * SubClass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again).\n     * @param missingAccountFunds - The minimum value this method should send the entrypoint.\n     *                              This value MAY be zero, in case there is enough deposit,\n     *                              or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            (bool success, ) = payable(msg.sender).call{\n                value: missingAccountFunds,\n                gas: type(uint256).max\n            }(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n}\n"
    },
    "contracts/core/BasePaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"./Helpers.sol\";\nimport \"./UserOperationLib.sol\";\n/**\n * Helper class for creating a paymaster.\n * provides helper methods for staking.\n * Validates that the postOp is called only by the entryPoint.\n */\nabstract contract BasePaymaster is IPaymaster, Ownable {\n    IEntryPoint public immutable entryPoint;\n\n    uint256 internal constant PAYMASTER_VALIDATION_GAS_OFFSET = UserOperationLib.PAYMASTER_VALIDATION_GAS_OFFSET;\n    uint256 internal constant PAYMASTER_POSTOP_GAS_OFFSET = UserOperationLib.PAYMASTER_POSTOP_GAS_OFFSET;\n    uint256 internal constant PAYMASTER_DATA_OFFSET = UserOperationLib.PAYMASTER_DATA_OFFSET;\n\n    constructor(IEntryPoint _entryPoint) Ownable(msg.sender) {\n        _validateEntryPointInterface(_entryPoint);\n        entryPoint = _entryPoint;\n    }\n\n    //sanity check: make sure this EntryPoint was compiled against the same\n    // IEntryPoint of this paymaster\n    function _validateEntryPointInterface(IEntryPoint _entryPoint) internal virtual {\n        require(IERC165(address(_entryPoint)).supportsInterface(type(IEntryPoint).interfaceId), \"IEntryPoint interface mismatch\");\n    }\n\n    /// @inheritdoc IPaymaster\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external override returns (bytes memory context, uint256 validationData) {\n        _requireFromEntryPoint();\n        return _validatePaymasterUserOp(userOp, userOpHash, maxCost);\n    }\n\n    /**\n     * Validate a user operation.\n     * @param userOp     - The user operation.\n     * @param userOpHash - The hash of the user operation.\n     * @param maxCost    - The maximum cost of the user operation.\n     */\n    function _validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal virtual returns (bytes memory context, uint256 validationData);\n\n    /// @inheritdoc IPaymaster\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external override {\n        _requireFromEntryPoint();\n        _postOp(mode, context, actualGasCost, actualUserOpFeePerGas);\n    }\n\n    /**\n     * Post-operation handler.\n     * (verified to be called only through the entryPoint)\n     * @dev If subclass returns a non-empty context from validatePaymasterUserOp,\n     *      it must also implement this method.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. still has to pay for gas.\n     *                        postOpReverted - User op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                                         Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n\n     */\n    function _postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) internal virtual {\n        (mode, context, actualGasCost, actualUserOpFeePerGas); // unused params\n        // subclass must override this method if validatePaymasterUserOp returns a context\n        revert(\"must override\");\n    }\n\n    /**\n     * Add a deposit for this paymaster, used for paying for transaction fees.\n     */\n    function deposit() public payable {\n        entryPoint.depositTo{value: msg.value}(address(this));\n    }\n\n    /**\n     * Withdraw value from the deposit.\n     * @param withdrawAddress - Target to send to.\n     * @param amount          - Amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 amount\n    ) public onlyOwner {\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * Add stake for this paymaster.\n     * This method can also carry eth value to add to the current stake.\n     * @param unstakeDelaySec - The unstake delay for this paymaster. Can only be increased.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n        entryPoint.addStake{value: msg.value}(unstakeDelaySec);\n    }\n\n    /**\n     * Return current paymaster's deposit on the entryPoint.\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint.balanceOf(address(this));\n    }\n\n    /**\n     * Unlock the stake, in order to withdraw it.\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\n     */\n    function unlockStake() external onlyOwner {\n        entryPoint.unlockStake();\n    }\n\n    /**\n     * Withdraw the entire paymaster's stake.\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\n        entryPoint.withdrawStake(withdrawAddress);\n    }\n\n    /**\n     * Validate the call is made from a valid entrypoint\n     */\n    function _requireFromEntryPoint() internal virtual {\n        require(msg.sender == address(entryPoint), \"Sender not EntryPoint\");\n    }\n}\n"
    },
    "contracts/core/EntryPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IAccountExecute.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\nimport \"./Helpers.sol\";\nimport \"./NonceManager.sol\";\nimport \"./UserOperationLib.sol\";\n\n// we also require '@gnosis.pm/safe-contracts' and both libraries have 'IERC165.sol', leading to conflicts\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\" as OpenZeppelin;\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/*\n * Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n * Only one instance required on each chain.\n */\ncontract EntryPoint is IEntryPoint, StakeManager, NonceManager, ReentrancyGuard, OpenZeppelin.ERC165 {\n\n    using UserOperationLib for PackedUserOperation;\n\n    SenderCreator private immutable _senderCreator = new SenderCreator();\n\n    function senderCreator() internal view virtual returns (SenderCreator) {\n        return _senderCreator;\n    }\n\n    //compensate for innerHandleOps' emit message and deposit refund.\n    // allow some slack for future gas price changes.\n    uint private constant INNER_GAS_OVERHEAD = 10000;\n\n    // Marker for inner call revert on out of gas\n    bytes32 private constant INNER_OUT_OF_GAS = hex\"deaddead\";\n\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\n    uint256 private constant PENALTY_PERCENT = 10;\n\n    /**\n     * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n     * must return this value in case of signature failure, instead of revert.\n     */\n    uint256 public constant SIG_VALIDATION_FAILED = 1;\n\n    /// @inheritdoc OpenZeppelin.IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // note: solidity \"type(IEntryPoint).interfaceId\" is without inherited methods but we want to check everything\n        return interfaceId == (type(IEntryPoint).interfaceId ^ type(IStakeManager).interfaceId ^ type(INonceManager).interfaceId) ||\n            interfaceId == type(IEntryPoint).interfaceId ||\n            interfaceId == type(IStakeManager).interfaceId ||\n            interfaceId == type(INonceManager).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * Compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary - The address to receive the fees.\n     * @param amount      - Amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success, ) = beneficiary.call{value: amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * Execute a user operation.\n     * @param opIndex    - Index into the opInfo array.\n     * @param userOp     - The userOp to execute.\n     * @param opInfo     - The opInfo filled by validatePrepayment for this userOp.\n     * @return collected - The total amount this userOp paid.\n     */\n    function _executeUserOp(\n        uint256 opIndex,\n        PackedUserOperation calldata userOp,\n        UserOpInfo memory opInfo\n    )\n    internal\n    returns\n    (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n        bool success;\n        {\n            uint saveFreePtr;\n            assembly (\"memory-safe\") {\n                saveFreePtr := mload(0x40)\n            }\n            bytes calldata callData = userOp.callData;\n            bytes memory innerCall;\n            bytes4 methodSig;\n            assembly {\n                let len := callData.length\n                if gt(len, 3) {\n                    methodSig := calldataload(callData.offset)\n                }\n            }\n            console.log(\"### _executeUserOp %s\", Strings.toHexString(uint32(methodSig)));\n            if (methodSig == IAccountExecute.executeUserOp.selector) {\n                bytes memory executeUserOp = abi.encodeCall(IAccountExecute.executeUserOp, (userOp, opInfo.userOpHash));\n                innerCall = abi.encodeCall(this.innerHandleOp, (executeUserOp, opInfo, context));\n            } else\n            {\n                innerCall = abi.encodeCall(this.innerHandleOp, (callData, opInfo, context));\n            }\n            assembly (\"memory-safe\") {\n                success := call(gas(), address(), 0, add(innerCall, 0x20), mload(innerCall), 0, 32)\n                collected := mload(0)\n                mstore(0x40, saveFreePtr)\n            }\n        }\n        if (!success) {\n            bytes32 innerRevertCode;\n            assembly (\"memory-safe\") {\n                let len := returndatasize()\n                if eq(32,len) {\n                    returndatacopy(0, 0, 32)\n                    innerRevertCode := mload(0)\n                }\n            }\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\n                //report paymaster, since if it is not deliberately caused by the bundler,\n                // it must be a revert caused by paymaster.\n                revert FailedOp(opIndex, \"AA95 out of gas\");\n            } else {\n                emit PostOpRevertReason(\n                    opInfo.userOpHash,\n                    opInfo.mUserOp.sender,\n                    opInfo.mUserOp.nonce,\n                    Exec.getReturnData(REVERT_REASON_MAX_LEN)\n                );\n            }\n\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            collected = _postExecution(\n                opIndex,\n                IPaymaster.PostOpMode.postOpReverted,\n                opInfo,\n                context,\n                actualGas\n            );\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) public nonReentrant {\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n        unchecked {\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[i];\n                (\n                    uint256 validationData,\n                    uint256 pmValidationData\n                ) = _validatePrepayment(i, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(\n                    i,\n                    validationData,\n                    pmValidationData,\n                    address(0)\n                );\n            }\n\n            uint256 collected = 0;\n            emit BeforeExecution();\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(i, ops[i], opInfos[i]);\n            }\n\n            _compensate(beneficiary, collected);\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public nonReentrant {\n\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[i];\n            PackedUserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            //address(1) is special marker of \"signature error\"\n            require(\n                address(aggregator) != address(1),\n                \"AA96 invalid aggregator\"\n            );\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {} catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n\n            totalOps += ops.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            PackedUserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[opIndex];\n                (\n                    uint256 validationData,\n                    uint256 paymasterValidationData\n                ) = _validatePrepayment(opIndex, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(\n                    i,\n                    validationData,\n                    paymasterValidationData,\n                    address(aggregator)\n                );\n                opIndex++;\n            }\n        }\n\n        emit BeforeExecution();\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            PackedUserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    /**\n     * A memory copy of UserOp static fields only.\n     * Excluding: callData, initCode and signature. Replacing paymasterAndData with paymaster.\n     */\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 verificationGasLimit;\n        uint256 callGasLimit;\n        uint256 paymasterVerificationGasLimit;\n        uint256 paymasterPostOpGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * Inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     * @param callData - The callData to execute.\n     * @param opInfo   - The UserOpInfo struct.\n     * @param context  - The context bytes.\n     */\n    function innerHandleOp(\n        bytes memory callData,\n        UserOpInfo memory opInfo,\n        bytes calldata context\n    ) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        uint256 callGasLimit = mUserOp.callGasLimit;\n        unchecked {\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (\n                gasleft() * 63 / 64 <\n                callGasLimit +\n                mUserOp.paymasterPostOpGasLimit +\n                INNER_GAS_OVERHEAD\n            ) {\n                assembly (\"memory-safe\") {\n                    mstore(0, INNER_OUT_OF_GAS)\n                    revert(0, 32)\n                }\n            }\n        }\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\n            if (!success) {\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(\n                        opInfo.userOpHash,\n                        mUserOp.sender,\n                        mUserOp.nonce,\n                        result\n                    );\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n        unchecked {\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            // Note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n            return _postExecution(0, mode, opInfo, context, actualGas);\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) public view returns (bytes32) {\n        return\n            keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * Copy general fields from userOp into the memory opInfo structure.\n     * @param userOp  - The user operation.\n     * @param mUserOp - The memory user operation.\n     */\n    function _copyUserOpToMemory(\n        PackedUserOperation calldata userOp,\n        MemoryUserOp memory mUserOp\n    ) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        (mUserOp.verificationGasLimit, mUserOp.callGasLimit) = UserOperationLib.unpackAccountGasLimits(userOp.accountGasLimits);\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(\n                paymasterAndData.length >= UserOperationLib.PAYMASTER_DATA_OFFSET,\n                \"AA93 invalid paymasterAndData\"\n            );\n            (mUserOp.paymaster, mUserOp.paymasterVerificationGasLimit, mUserOp.paymasterPostOpGasLimit) = UserOperationLib.unpackPaymasterStaticFields(paymasterAndData);\n        } else {\n            mUserOp.paymaster = address(0);\n            mUserOp.paymasterVerificationGasLimit = 0;\n            mUserOp.paymasterPostOpGasLimit = 0;\n        }\n    }\n\n    /**\n     * Get the required prefunded gas fee amount for an operation.\n     * @param mUserOp - The user operation in memory.\n     */\n    function _getRequiredPrefund(\n        MemoryUserOp memory mUserOp\n    ) internal pure returns (uint256 requiredPrefund) {\n        unchecked {\n            uint256 requiredGas = mUserOp.verificationGasLimit +\n                mUserOp.callGasLimit +\n                mUserOp.paymasterVerificationGasLimit +\n                mUserOp.paymasterPostOpGasLimit +\n                mUserOp.preVerificationGas;\n\n            requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\n        }\n    }\n\n    /**\n     * Create sender smart contract account if init code is provided.\n     * @param opIndex  - The operation index.\n     * @param opInfo   - The operation info.\n     * @param initCode - The init code for the smart contract account.\n     */\n    function _createSenderIfNeeded(\n        uint256 opIndex,\n        UserOpInfo memory opInfo,\n        bytes calldata initCode\n    ) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0)\n                revert FailedOp(opIndex, \"AA10 sender already constructed\");\n            address sender1 = senderCreator().createSender{\n                gas: opInfo.mUserOp.verificationGasLimit\n            }(initCode);\n            if (sender1 == address(0))\n                revert FailedOp(opIndex, \"AA13 initCode failed or OOG\");\n            if (sender1 != sender)\n                revert FailedOp(opIndex, \"AA14 initCode must return sender\");\n            if (sender1.code.length == 0)\n                revert FailedOp(opIndex, \"AA15 initCode must create sender\");\n            address factory = address(bytes20(initCode[0:20]));\n            emit AccountDeployed(\n                opInfo.userOpHash,\n                sender,\n                factory,\n                opInfo.mUserOp.paymaster\n            );\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function getSenderAddress(bytes calldata initCode) public {\n        address sender = senderCreator().createSender(initCode);\n        revert SenderAddressResult(sender);\n    }\n\n    /**\n     * Call account.validateUserOp.\n     * Revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * Decrement account's deposit if needed.\n     * @param opIndex         - The operation index.\n     * @param op              - The user operation.\n     * @param opInfo          - The operation info.\n     * @param requiredPrefund - The required prefund amount.\n     */\n    function _validateAccountPrepayment(\n        uint256 opIndex,\n        PackedUserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPrefund\n    )\n        internal\n        returns (\n            uint256 validationData\n        )\n    {\n        unchecked {\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            address sender = mUserOp.sender;\n            _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n            address paymaster = mUserOp.paymaster;\n            uint256 missingAccountFunds = 0;\n            if (paymaster == address(0)) {\n                uint256 bal = balanceOf(sender);\n                missingAccountFunds = bal > requiredPrefund\n                    ? 0\n                    : requiredPrefund - bal;\n            }\n            try\n                IAccount(sender).validateUserOp{\n                    gas: mUserOp.verificationGasLimit\n                }(op, opInfo.userOpHash, missingAccountFunds)\n            returns (uint256 _validationData) {\n                validationData = _validationData;\n            } catch {\n                revert FailedOpWithRevert(opIndex, \"AA23 reverted\", Exec.getReturnData(REVERT_REASON_MAX_LEN));\n            }\n            if (paymaster == address(0)) {\n                DepositInfo storage senderInfo = deposits[sender];\n                uint256 deposit = senderInfo.deposit;\n                if (requiredPrefund > deposit) {\n                    revert FailedOp(opIndex, \"AA21 didn't pay prefund\");\n                }\n                senderInfo.deposit = deposit - requiredPrefund;\n            }\n        }\n    }\n\n    /**\n     * In case the request has a paymaster:\n     *  - Validate paymaster has enough deposit.\n     *  - Call paymaster.validatePaymasterUserOp.\n     *  - Revert with proper FailedOp in case paymaster reverts.\n     *  - Decrement paymaster's deposit.\n     * @param opIndex                            - The operation index.\n     * @param op                                 - The user operation.\n     * @param opInfo                             - The operation info.\n     * @param requiredPreFund                    - The required prefund amount.\n     */\n    function _validatePaymasterPrepayment(\n        uint256 opIndex,\n        PackedUserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPreFund\n    ) internal returns (bytes memory context, uint256 validationData) {\n        unchecked {\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            address paymaster = mUserOp.paymaster;\n            DepositInfo storage paymasterInfo = deposits[paymaster];\n            uint256 deposit = paymasterInfo.deposit;\n            if (deposit < requiredPreFund) {\n                revert FailedOp(opIndex, \"AA31 paymaster deposit too low\");\n            }\n            paymasterInfo.deposit = deposit - requiredPreFund;\n            try\n                IPaymaster(paymaster).validatePaymasterUserOp{gas: mUserOp.paymasterVerificationGasLimit}(\n                    op,\n                    opInfo.userOpHash,\n                    requiredPreFund\n                )\n            returns (bytes memory _context, uint256 _validationData) {\n                context = _context;\n                validationData = _validationData;\n            } catch {\n                revert FailedOpWithRevert(opIndex, \"AA33 reverted\", Exec.getReturnData(REVERT_REASON_MAX_LEN));\n            }\n        }\n    }\n\n    /**\n     * Revert if either account validationData or paymaster validationData is expired.\n     * @param opIndex                 - The operation index.\n     * @param validationData          - The account validationData.\n     * @param paymasterValidationData - The paymaster validationData.\n     * @param expectedAggregator      - The expected aggregator.\n     */\n    function _validateAccountAndPaymasterValidationData(\n        uint256 opIndex,\n        uint256 validationData,\n        uint256 paymasterValidationData,\n        address expectedAggregator\n    ) internal view {\n        (address aggregator, bool outOfTimeRange) = _getValidationData(\n            validationData\n        );\n        if (expectedAggregator != aggregator) {\n            revert FailedOp(opIndex, \"AA24 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA22 expired or not due\");\n        }\n        // pmAggregator is not a real signature aggregator: we don't have logic to handle it as address.\n        // Non-zero address means that the paymaster fails due to some signature check (which is ok only during estimation).\n        address pmAggregator;\n        (pmAggregator, outOfTimeRange) = _getValidationData(\n            paymasterValidationData\n        );\n        if (pmAggregator != address(0)) {\n            revert FailedOp(opIndex, \"AA34 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA32 paymaster expired or not due\");\n        }\n    }\n\n    /**\n     * Parse validationData into its components.\n     * @param validationData - The packed validation data (sigFailed, validAfter, validUntil).\n     */\n    function _getValidationData(\n        uint256 validationData\n    ) internal view returns (address aggregator, bool outOfTimeRange) {\n        if (validationData == 0) {\n            return (address(0), false);\n        }\n        ValidationData memory data = _parseValidationData(validationData);\n        // solhint-disable-next-line not-rely-on-time\n        outOfTimeRange = block.timestamp > data.validUntil || block.timestamp < data.validAfter;\n        aggregator = data.aggregator;\n    }\n\n    /**\n     * Validate account and paymaster (if defined) and\n     * also make sure total validation doesn't exceed verificationGasLimit.\n     * This method is called off-chain (simulateValidation()) and on-chain (from handleOps)\n     * @param opIndex - The index of this userOp into the \"opInfos\" array.\n     * @param userOp  - The userOp to validate.\n     */\n    function _validatePrepayment(\n        uint256 opIndex,\n        PackedUserOperation calldata userOp,\n        UserOpInfo memory outOpInfo\n    )\n        internal\n        returns (uint256 validationData, uint256 paymasterValidationData)\n    {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n        _copyUserOpToMemory(userOp, mUserOp);\n        outOpInfo.userOpHash = getUserOpHash(userOp);\n\n        // Validate all numeric values in userOp are well below 128 bit, so they can safely be added\n        // and multiplied without causing overflow.\n        uint256 maxGasValues = mUserOp.preVerificationGas |\n            mUserOp.verificationGasLimit |\n            mUserOp.callGasLimit |\n            mUserOp.paymasterVerificationGasLimit |\n            mUserOp.paymasterPostOpGasLimit |\n            userOp.maxFeePerGas |\n            userOp.maxPriorityFeePerGas;\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\n\n        uint256 requiredPreFund = _getRequiredPrefund(mUserOp);\n        validationData = _validateAccountPrepayment(\n            opIndex,\n            userOp,\n            outOpInfo,\n            requiredPreFund\n        );\n\n        if (!_validateAndUpdateNonce(mUserOp.sender, mUserOp.nonce)) {\n            revert FailedOp(opIndex, \"AA25 invalid account nonce\");\n        }\n\n        bytes memory context;\n        if (mUserOp.paymaster != address(0)) {\n            (context, paymasterValidationData) = _validatePaymasterPrepayment(\n                opIndex,\n                userOp,\n                outOpInfo,\n                requiredPreFund\n            );\n        }\n        unchecked {\n            uint256 gasUsed = preGas - gasleft();\n\n            if (mUserOp.verificationGasLimit + mUserOp.paymasterVerificationGasLimit < gasUsed) {\n                revert FailedOp(opIndex, \"AA40 over verificationGasLimit\");\n            }\n            outOpInfo.prefund = requiredPreFund;\n            outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n            outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n        }\n    }\n\n    /**\n     * Process post-operation, called just after the callData is executed.\n     * If a paymaster is defined and its validation returned a non-empty context, its postOp is called.\n     * The excess amount is refunded to the account (or paymaster - if it was used in the request).\n     * @param opIndex   - Index in the batch.\n     * @param mode      - Whether is called from innerHandleOp, or outside (postOpReverted).\n     * @param opInfo    - UserOp fields and info collected during validation.\n     * @param context   - The context returned in validatePaymasterUserOp.\n     * @param actualGas - The gas used so far by this user operation.\n     */\n    function _postExecution(\n        uint256 opIndex,\n        IPaymaster.PostOpMode mode,\n        UserOpInfo memory opInfo,\n        bytes memory context,\n        uint256 actualGas\n    ) private returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        unchecked {\n            address refundAddress;\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n            address paymaster = mUserOp.paymaster;\n            if (paymaster == address(0)) {\n                refundAddress = mUserOp.sender;\n            } else {\n                refundAddress = paymaster;\n                if (context.length > 0) {\n                    actualGasCost = actualGas * gasPrice;\n                    if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                        try IPaymaster(paymaster).postOp{\n                            gas: mUserOp.paymasterPostOpGasLimit\n                        }(mode, context, actualGasCost, gasPrice)\n                        // solhint-disable-next-line no-empty-blocks\n                        {} catch {\n                            bytes memory reason = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                            revert PostOpReverted(reason);\n                        }\n                    }\n                }\n            }\n            actualGas += preGas - gasleft();\n\n            // Calculating a penalty for unused execution gas\n            {\n                uint256 executionGasLimit = mUserOp.callGasLimit;\n                // Note that 'verificationGasLimit' here is the limit given to the 'postOp' which is part of execution\n                if (context.length > 0){\n                    executionGasLimit += mUserOp.paymasterPostOpGasLimit;\n                }\n                uint256 executionGasUsed = actualGas - opInfo.preOpGas;\n                // this check is required for the gas used within EntryPoint and not covered by explicit gas limits\n                if (executionGasLimit > executionGasUsed) {\n                    uint256 unusedGas = executionGasLimit - executionGasUsed;\n                    uint256 unusedGasPenalty = (unusedGas * PENALTY_PERCENT) / 100;\n                    actualGas += unusedGasPenalty;\n                }\n            }\n\n            actualGasCost = actualGas * gasPrice;\n            if (opInfo.prefund < actualGasCost) {\n                revert FailedOp(opIndex, \"AA51 prefund below actualGasCost\");\n            }\n            uint256 refund = opInfo.prefund - actualGasCost;\n            _incrementDeposit(refundAddress, refund);\n            bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n            emit UserOperationEvent(\n                opInfo.userOpHash,\n                mUserOp.sender,\n                mUserOp.paymaster,\n                mUserOp.nonce,\n                success,\n                actualGasCost,\n                actualGas\n            );\n        } // unchecked\n    }\n\n    /**\n     * The gas price this UserOp agrees to pay.\n     * Relayer/block builder might submit the TX with higher priorityFee, but the user should not.\n     * @param mUserOp - The userOp to get the gas price from.\n     */\n    function getUserOpGasPrice(\n        MemoryUserOp memory mUserOp\n    ) internal view returns (uint256) {\n        unchecked {\n            uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n            uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * The offset of the given bytes in memory.\n     * @param data - The bytes to get the offset of.\n     */\n    function getOffsetOfMemoryBytes(\n        bytes memory data\n    ) internal pure returns (uint256 offset) {\n        assembly {\n            offset := data\n        }\n    }\n\n    /**\n     * The bytes in memory at the given offset.\n     * @param offset - The offset to get the bytes from.\n     */\n    function getMemoryBytesFromOffset(\n        uint256 offset\n    ) internal pure returns (bytes memory data) {\n        assembly (\"memory-safe\") {\n            data := offset\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function delegateAndRevert(address target, bytes calldata data) external {\n        (bool success, bytes memory ret) = target.delegatecall(data);\n        revert DelegateAndRevert(success, ret);\n    }\n}\n"
    },
    "contracts/core/EntryPointSimulations.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"./EntryPoint.sol\";\nimport \"../interfaces/IEntryPointSimulations.sol\";\n\n/*\n * This contract inherits the EntryPoint and extends it with the view-only methods that are executed by\n * the bundler in order to check UserOperation validity and estimate its gas consumption.\n * This contract should never be deployed on-chain and is only used as a parameter for the \"eth_call\" request.\n */\ncontract EntryPointSimulations is EntryPoint, IEntryPointSimulations {\n    // solhint-disable-next-line var-name-mixedcase\n    AggregatorStakeInfo private NOT_AGGREGATED = AggregatorStakeInfo(address(0), StakeInfo(0, 0));\n\n    SenderCreator private _senderCreator;\n\n    function initSenderCreator() internal virtual {\n        //this is the address of the first contract created with CREATE by this address.\n        address createdObj = address(uint160(uint256(keccak256(abi.encodePacked(hex\"d694\", address(this), hex\"01\")))));\n        _senderCreator = SenderCreator(createdObj);\n    }\n\n    function senderCreator() internal view virtual override returns (SenderCreator) {\n        // return the same senderCreator as real EntryPoint.\n        // this call is slightly (100) more expensive than EntryPoint's access to immutable member\n        return _senderCreator;\n    }\n\n    /**\n     * simulation contract should not be deployed, and specifically, accounts should not trust\n     * it as entrypoint, since the simulation functions don't check the signatures\n     */\n    constructor() {\n        require(block.number < 100, \"should not be deployed\");\n    }\n\n    /// @inheritdoc IEntryPointSimulations\n    function simulateValidation(\n        PackedUserOperation calldata userOp\n    )\n    external\n    returns (\n        ValidationResult memory\n    ){\n        UserOpInfo memory outOpInfo;\n\n        //initialize senderCreator(). we can't rely on constructor\n        initSenderCreator();\n        _simulationOnlyValidations(userOp);\n        (\n            uint256 validationData,\n            uint256 paymasterValidationData\n        ) = _validatePrepayment(0, userOp, outOpInfo);\n        StakeInfo memory paymasterInfo = _getStakeInfo(\n            outOpInfo.mUserOp.paymaster\n        );\n        StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\n        StakeInfo memory factoryInfo;\n        {\n            bytes calldata initCode = userOp.initCode;\n            address factory = initCode.length >= 20\n                ? address(bytes20(initCode[0 : 20]))\n                : address(0);\n            factoryInfo = _getStakeInfo(factory);\n        }\n\n        ValidationData memory data = _intersectTimeRange(\n            validationData,\n            paymasterValidationData\n        );\n        address aggregator = data.aggregator;\n        bool sigFailed = aggregator == address(1);\n        ReturnInfo memory returnInfo = ReturnInfo(\n            outOpInfo.preOpGas,\n            outOpInfo.prefund,\n            sigFailed,\n            data.validAfter,\n            data.validUntil,\n            getMemoryBytesFromOffset(outOpInfo.contextOffset)\n        );\n\n        AggregatorStakeInfo memory aggregatorInfo = NOT_AGGREGATED;\n        if (aggregator != address(0) && aggregator != address(1)) {\n            aggregatorInfo = AggregatorStakeInfo(\n                aggregator,\n                _getStakeInfo(aggregator)\n            );\n        }\n        return ValidationResult(\n            returnInfo,\n            senderInfo,\n            factoryInfo,\n            paymasterInfo,\n            aggregatorInfo\n        );\n    }\n\n    /// @inheritdoc IEntryPointSimulations\n    function simulateHandleOp(\n        PackedUserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    )\n    external nonReentrant\n    returns (\n        ExecutionResult memory\n    ){\n        UserOpInfo memory opInfo;\n        _simulationOnlyValidations(op);\n        (\n            uint256 validationData,\n            uint256 paymasterValidationData\n        ) = _validatePrepayment(0, op, opInfo);\n        ValidationData memory data = _intersectTimeRange(\n            validationData,\n            paymasterValidationData\n        );\n\n        uint256 paid = _executeUserOp(0, op, opInfo);\n        bool targetSuccess;\n        bytes memory targetResult;\n        if (target != address(0)) {\n            (targetSuccess, targetResult) = target.call(targetCallData);\n        }\n        return ExecutionResult(\n            opInfo.preOpGas,\n            paid,\n            data.validAfter,\n            data.validUntil,\n            targetSuccess,\n            targetResult\n        );\n    }\n\n    function _simulationOnlyValidations(\n        PackedUserOperation calldata userOp\n    )\n    internal\n    view\n    {\n        try\n        this._validateSenderAndPaymaster(\n            userOp.initCode,\n            userOp.sender,\n            userOp.paymasterAndData\n        )\n        // solhint-disable-next-line no-empty-blocks\n        {} catch Error(string memory revertReason) {\n            if (bytes(revertReason).length != 0) {\n                revert FailedOp(0, revertReason);\n            }\n        }\n    }\n\n    /**\n     * Called only during simulation.\n     * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\n     * @param initCode         - The smart account constructor code.\n     * @param sender           - The sender address.\n     * @param paymasterAndData - The paymaster address followed by the token address to use.\n     */\n    function _validateSenderAndPaymaster(\n        bytes calldata initCode,\n        address sender,\n        bytes calldata paymasterAndData\n    ) external view {\n        if (initCode.length == 0 && sender.code.length == 0) {\n            // it would revert anyway. but give a meaningful message\n            revert(\"AA20 account not deployed\");\n        }\n        if (paymasterAndData.length >= 20) {\n            address paymaster = address(bytes20(paymasterAndData[0 : 20]));\n            if (paymaster.code.length == 0) {\n                // It would revert anyway. but give a meaningful message.\n                revert(\"AA30 paymaster not deployed\");\n            }\n        }\n        // always revert\n        revert(\"\");\n    }\n\n    //make sure depositTo cost is more than normal EntryPoint's cost,\n    // to mitigate DoS vector on the bundler\n    // empiric test showed that without this wrapper, simulation depositTo costs less..\n    function depositTo(address account) public override(IStakeManager, StakeManager) payable {\n        unchecked{\n        // silly code, to waste some gas to make sure depositTo is always little more\n        // expensive than on-chain call\n            uint x = 1;\n            while (x < 5) {\n                x++;\n            }\n            StakeManager.depositTo(account);\n        }\n    }\n}\n"
    },
    "contracts/core/Helpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable no-inline-assembly */\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validaUntil - This UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Intersect account and paymaster ranges.\n * @param validationData          - The packed validation data of the account.\n * @param paymasterValidationData - The packed validation data of the paymaster.\n */\nfunction _intersectTimeRange(\n    uint256 validationData,\n    uint256 paymasterValidationData\n) pure returns (ValidationData memory) {\n    ValidationData memory accountValidationData = _parseValidationData(\n        validationData\n    );\n    ValidationData memory pmValidationData = _parseValidationData(\n        paymasterValidationData\n    );\n    address aggregator = accountValidationData.aggregator;\n    if (aggregator == address(0)) {\n        aggregator = pmValidationData.aggregator;\n    }\n    uint48 validAfter = accountValidationData.validAfter;\n    uint48 validUntil = accountValidationData.validUntil;\n    uint48 pmValidAfter = pmValidationData.validAfter;\n    uint48 pmValidUntil = pmValidationData.validUntil;\n\n    if (validAfter < pmValidAfter) validAfter = pmValidAfter;\n    if (validUntil > pmValidUntil) validUntil = pmValidUntil;\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\n * @param validAfter - First timestamp this UserOperation is valid.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n"
    },
    "contracts/core/NonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IEntryPoint.sol\";\n\n/**\n * nonce management functionality\n */\nabstract contract NonceManager is INonceManager {\n\n    /**\n     * The next valid sequence number for a given nonce key.\n     */\n    mapping(address => mapping(uint192 => uint256)) public nonceSequenceNumber;\n\n    function getNonce(address sender, uint192 key)\n    public view override returns (uint256 nonce) {\n        return nonceSequenceNumber[sender][key] | (uint256(key) << 64);\n    }\n\n    // allow an account to manually increment its own nonce.\n    // (mainly so that during construction nonce can be made non-zero,\n    // to \"absorb\" the gas cost of first nonce increment to 1st transaction (construction),\n    // not to 2nd transaction)\n    function incrementNonce(uint192 key) public override {\n        nonceSequenceNumber[msg.sender][key]++;\n    }\n\n    /**\n     * validate nonce uniqueness for this account.\n     * called just after validateUserOp()\n     */\n    function _validateAndUpdateNonce(address sender, uint256 nonce) internal returns (bool) {\n\n        uint192 key = uint192(nonce >> 64);\n        uint64 seq = uint64(nonce);\n        return nonceSequenceNumber[sender][key]++ == seq;\n    }\n\n}\n"
    },
    "contracts/core/SenderCreator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/**\n * Helper contract for EntryPoint, to call userOp.initCode from a \"neutral\" address,\n * which is explicitly not the entryPoint itself.\n */\ncontract SenderCreator {\n    /**\n     * Call the \"initCode\" factory to create and return the sender account address.\n     * @param initCode - The initCode value from a UserOp. contains 20 bytes of factory address,\n     *                   followed by calldata.\n     * @return sender  - The returned address of the created account, or zero address on failure.\n     */\n    function createSender(\n        bytes calldata initCode\n    ) external returns (address sender) {\n        address factory = address(bytes20(initCode[0:20]));\n        bytes memory initCallData = initCode[20:];\n        bool success;\n        /* solhint-disable no-inline-assembly */\n        assembly (\"memory-safe\") {\n            success := call(\n                gas(),\n                factory,\n                0,\n                add(initCallData, 0x20),\n                mload(initCallData),\n                0,\n                32\n            )\n            sender := mload(0)\n        }\n        if (!success) {\n            sender = address(0);\n        }\n    }\n}\n"
    },
    "contracts/core/StakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IStakeManager.sol\";\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable not-rely-on-time */\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by a paymaster.\n */\nabstract contract StakeManager is IStakeManager {\n    /// maps paymaster to their deposits and stakes\n    mapping(address => DepositInfo) public deposits;\n\n    /// @inheritdoc IStakeManager\n    function getDepositInfo(\n        address account\n    ) public view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    /**\n     * Internal method to return just the stake info.\n     * @param addr - The account to query.\n     */\n    function _getStakeInfo(\n        address addr\n    ) internal view returns (StakeInfo memory info) {\n        DepositInfo storage depositInfo = deposits[addr];\n        info.stake = depositInfo.stake;\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\n    }\n\n    /**\n     * Return the deposit (for gas payment) of the account.\n     * @param account - The account to query.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits[account].deposit;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    /**\n     * Increments an account's deposit.\n     * @param account - The account to increment.\n     * @param amount  - The amount to increment by.\n     */\n    function _incrementDeposit(address account, uint256 amount) internal returns (uint256) {\n        DepositInfo storage info = deposits[account];\n        uint256 newAmount = info.deposit + amount;\n        info.deposit = newAmount;\n        return newAmount;\n    }\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) public virtual payable {\n        uint256 newDeposit = _incrementDeposit(account, msg.value);\n        emit Deposited(account, newDeposit);\n    }\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param unstakeDelaySec The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[msg.sender];\n        require(unstakeDelaySec > 0, \"must specify unstake delay\");\n        require(\n            unstakeDelaySec >= info.unstakeDelaySec,\n            \"cannot decrease unstake time\"\n        );\n        uint256 stake = info.stake + msg.value;\n        require(stake > 0, \"no stake specified\");\n        require(stake <= type(uint112).max, \"stake overflow\");\n        deposits[msg.sender] = DepositInfo(\n            info.deposit,\n            true,\n            uint112(stake),\n            unstakeDelaySec,\n            0\n        );\n        emit StakeLocked(msg.sender, stake, unstakeDelaySec);\n    }\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        require(info.staked, \"already unstaking\");\n        uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        info.staked = false;\n        emit StakeUnlocked(msg.sender, withdrawTime);\n    }\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external {\n        DepositInfo storage info = deposits[msg.sender];\n        uint256 stake = info.stake;\n        require(stake > 0, \"No stake to withdraw\");\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\n        require(\n            info.withdrawTime <= block.timestamp,\n            \"Stake withdrawal is not due\"\n        );\n        info.unstakeDelaySec = 0;\n        info.withdrawTime = 0;\n        info.stake = 0;\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\n        (bool success,) = withdrawAddress.call{value: stake}(\"\");\n        require(success, \"failed to withdraw stake\");\n    }\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n        info.deposit = info.deposit - withdrawAmount;\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n        (bool success,) = withdrawAddress.call{value: withdrawAmount}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n}\n"
    },
    "contracts/core/UserOperationLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport {calldataKeccak, min} from \"./Helpers.sol\";\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n    /**\n     * Get sender from user operation data.\n     * @param userOp - The user operation data.\n     */\n    function getSender(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    /**\n     * Relayer/block builder might submit the TX with higher priorityFee,\n     * but the user should not pay above what he signed for.\n     * @param userOp - The user operation data.\n     */\n    function gasPrice(\n        PackedUserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            uint256 maxFeePerGas = userOp.maxFeePerGas;\n            uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * Pack the user operation data into bytes for hashing.\n     * @param userOp - The user operation data.\n     */\n    function encode(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        bytes32 accountGasLimits = userOp.accountGasLimits;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            sender, nonce,\n            hashInitCode, hashCallData,\n            accountGasLimits, preVerificationGas,\n            maxFeePerGas, maxPriorityFeePerGas,\n            hashPaymasterAndData\n        );\n    }\n\n    function unpackAccountGasLimits(\n        bytes32 accountGasLimits\n    ) internal pure returns (uint256 validationGasLimit, uint256 callGasLimit) {\n        return (uint128(bytes16(accountGasLimits)), uint128(uint256(accountGasLimits)));\n    }\n\n    function unpackPaymasterStaticFields(\n        bytes calldata paymasterAndData\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOp) {\n        return (\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\n        );\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp - The user operation data.\n     */\n    function hash(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes32) {\n        return keccak256(encode(userOp));\n    }\n}\n"
    },
    "contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"
    },
    "contracts/interfaces/IAccountExecute.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccountExecute {\n    /**\n     * Account may implement this execute method.\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the full UserOp (and hash)\n     * to the account.\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp fields)\n     *\n     * @param userOp              - The operation that was just validated.\n     * @param userOpHash          - Hash of the user's request data.\n     */\n    function executeUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external;\n}\n"
    },
    "contracts/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"
    },
    "contracts/interfaces/IEntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted by handleOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps, to identify the offending op.\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     * @param userOp - The user operation to generate the request ID for.\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param sigFailed        - ValidateUserOp's (or paymaster's) signature check failed\n     * @param validAfter       - First timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param validUntil       - Last timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        bool sigFailed;\n        uint48 validAfter;\n        uint48 validUntil;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Returned aggregated signature info:\n     * The aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n}\n"
    },
    "contracts/interfaces/IEntryPointSimulations.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IEntryPoint.sol\";\n\ninterface IEntryPointSimulations is IEntryPoint {\n    // Return value of simulateHandleOp.\n    struct ExecutionResult {\n        uint256 preOpGas;\n        uint256 paid;\n        uint48 validAfter;\n        uint48 validUntil;\n        bool targetSuccess;\n        bytes targetResult;\n    }\n\n    /**\n     * Successful result from simulateValidation.\n     * If the account returns a signature aggregator the \"aggregatorInfo\" struct is filled in as well.\n     * @param returnInfo     Gas and time-range returned values\n     * @param senderInfo     Stake information about the sender\n     * @param factoryInfo    Stake information about the factory (if any)\n     * @param paymasterInfo  Stake information about the paymaster (if any)\n     * @param aggregatorInfo Signature aggregation info (if the account requires signature aggregator)\n     *                       Bundler MUST use it to verify the signature, or reject the UserOperation.\n     */\n    struct ValidationResult {\n        ReturnInfo returnInfo;\n        StakeInfo senderInfo;\n        StakeInfo factoryInfo;\n        StakeInfo paymasterInfo;\n        AggregatorStakeInfo aggregatorInfo;\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev This method always reverts. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage\n     *      outside the account's data.\n     * @param userOp - The user operation to validate.\n     */\n    function simulateValidation(\n        PackedUserOperation calldata userOp\n    )\n    external\n    returns (\n        ValidationResult memory\n    );\n\n    /**\n     * Simulate full execution of a UserOperation (including both validation and target execution)\n     * This method will always revert with \"ExecutionResult\".\n     * It performs full validation of the UserOperation, but ignores signature error.\n     * An optional target address is called after the userop succeeds,\n     * and its value is returned (before the entire call is reverted).\n     * Note that in order to collect the the success/failure of the target call, it must be executed\n     * with trace enabled to track the emitted events.\n     * @param op The UserOperation to simulate.\n     * @param target         - If nonzero, a target address to call after userop simulation. If called,\n     *                         the targetSuccess and targetResult are set to the return from that call.\n     * @param targetCallData - CallData to pass to target address.\n     */\n    function simulateHandleOp(\n        PackedUserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    )\n    external\n    returns (\n        ExecutionResult memory\n    );\n}\n"
    },
    "contracts/interfaces/INonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"
    },
    "contracts/interfaces/IPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * The interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * A paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n    enum PostOpMode {\n        // User op succeeded.\n        opSucceeded,\n        // User op reverted. Still has to pay for gas.\n        opReverted,\n        // User op succeeded, but caused postOp to revert.\n        // Only used internally in the EntryPoint - Paymasters will not be called again.\n        postOpReverted\n    }\n\n    /**\n     * Payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted).\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp          - The user operation.\n     * @param userOpHash      - Hash of the user's request data.\n     * @param maxCost         - The maximum cost of this transaction (based on maximum gas and gas price from userOp).\n     * @return context        - Value to send to a postOp. Zero length to signify postOp is not required.\n     * @return validationData - Signature and time-range of this operation, encoded the same as the return\n     *                          value of validateUserOperation.\n     *                          <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                                    otherwise, an address of an \"authorizer\" contract.\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *                          <6-byte> validAfter - first timestamp this operation is valid\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * Post-operation handler.\n     * Must verify sender is the entryPoint.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. still has to pay for gas.\n     *                        postOpReverted - User op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                                         Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualGasCost - Actual gas used so far (without this postOp call).\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n     */\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external;\n}\n"
    },
    "contracts/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\n     *      and the rest fit into a 2nd cell.\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"
    },
    "contracts/interfaces/PackedUserOperation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param maxFeePerGas          - Same as EIP-1559 gas parameter.\n * @param maxPriorityFeePerGas  - Same as EIP-1559 gas parameter.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    uint256 maxFeePerGas;\n    uint256 maxPriorityFeePerGas;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"
    },
    "contracts/legacy/v06/IAccount06.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation06.sol\";\n\ninterface IAccount06 {\n\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp the operation that is about to be executed.\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\n     *      The excess is left as a deposit in the entrypoint, for future calls.\n     *      can be withdrawn anytime using \"entryPoint.withdrawTo()\"\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\n     * @return validationData packaged ValidationData structure. use `_packValidationData` and `_unpackValidationData` to encode and decode\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      If an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(UserOperation06 calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\n    external returns (uint256 validationData);\n}\n"
    },
    "contracts/legacy/v06/IAggregator06.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation06.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator06 {\n\n    /**\n     * validate aggregated signature.\n     * revert if the aggregated signature does not match the given list of operations.\n     */\n    function validateSignatures(UserOperation06[] calldata userOps, bytes calldata signature) external view;\n\n    /**\n     * validate signature of a single userOp\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(UserOperation06 calldata userOp)\n    external view returns (bytes memory sigForUserOp);\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature the aggregated signature\n     */\n    function aggregateSignatures(UserOperation06[] calldata userOps) external view returns (bytes memory aggregatedSignature);\n}\n"
    },
    "contracts/legacy/v06/IEntryPoint06.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./UserOperation06.sol\";\nimport \"./IStakeManager06.sol\";\nimport \"./IAggregator06.sol\";\nimport \"./INonceManager06.sol\";\n\ninterface IEntryPoint is IStakeManager06, INonceManager06 {\n\n    /***\n     * An event emitted after each successful request\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\n     * @param sender - the account that generates this request.\n     * @param paymaster - if non-null, the paymaster that pays for this request.\n     * @param nonce - the nonce value from the request.\n     * @param success - true if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\n     */\n    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);\n\n    /**\n     * account \"sender\" was deployed.\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender the account that is deployed\n     * @param factory the factory used to deploy this account (in the initCode)\n     * @param paymaster the paymaster used by this UserOp\n     */\n    event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length\n     * @param userOpHash the request unique identifier.\n     * @param sender the sender of this request\n     * @param nonce the nonce used in the request\n     * @param revertReason - the return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);\n\n    /**\n     * an event emitted by handleOps(), before starting the execution loop.\n     * any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * signature aggregator used by the following UserOperationEvents within this bundle.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * a custom revert error of handleOps, to identify the offending op.\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\n     *  @param reason - revert reason\n     *      The string starts with a unique code \"AAmn\", where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *      so a failure can be attributed to the correct entity.\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    /**\n     * Successful result from simulateValidation.\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factory (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     */\n    error ValidationResult(ReturnInfo returnInfo,\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\n\n    /**\n     * Successful result from simulateValidation, if the account returns a signature aggregator\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factory (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\n     */\n    error ValidationResultWithAggregation(ReturnInfo returnInfo,\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo,\n        AggregatorStakeInfo aggregatorInfo);\n\n    /**\n     * return value of getSenderAddress\n     */\n    error SenderAddressResult(address sender);\n\n    /**\n     * return value of simulateHandleOp\n     */\n    error ExecutionResult(uint256 preOpGas, uint256 paid, uint48 validAfter, uint48 validUntil, bool targetSuccess, bytes targetResult);\n\n    //UserOps handled, per aggregator\n    struct UserOpsPerAggregator {\n        UserOperation06[] userOps;\n\n        // aggregator address\n        IAggregator06 aggregator;\n        // aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation06[] calldata ops, address payable beneficiary) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation06 calldata userOp) external view returns (bytes32);\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation06 calldata userOp) external;\n\n    /**\n     * gas and return values during simulation\n     * @param preOpGas the gas used for validation (including preValidationGas)\n     * @param prefund the required prefund for this operation\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        bool sigFailed;\n        uint48 validAfter;\n        uint48 validUntil;\n        bytes paymasterContext;\n    }\n\n    /**\n     * returned aggregated signature info.\n     * the aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n\n    /**\n     * simulate full execution of a UserOperation (including both validation and target execution)\n     * this method will always revert with \"ExecutionResult\".\n     * it performs full validation of the UserOperation, but ignores signature error.\n     * an optional target address is called after the userop succeeds, and its value is returned\n     * (before the entire call is reverted)\n     * Note that in order to collect the the success/failure of the target call, it must be executed\n     * with trace enabled to track the emitted events.\n     * @param op the UserOperation to simulate\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\n     *        are set to the return from that call.\n     * @param targetCallData callData to pass to target address\n     */\n    function simulateHandleOp(UserOperation06 calldata op, address target, bytes calldata targetCallData) external;\n}\n"
    },
    "contracts/legacy/v06/INonceManager06.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\ninterface INonceManager06 {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"
    },
    "contracts/legacy/v06/IPaymaster06.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation06.sol\";\n\n/**\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster06 {\n\n    enum PostOpMode {\n        opSucceeded, // user op succeeded\n        opReverted, // user op reverted. still has to pay for gas.\n        postOpReverted //user op succeeded, but caused postOp to revert. Now it's a 2nd call, after user's op was deliberately reverted.\n    }\n\n    /**\n     * payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp the user operation\n     * @param userOpHash hash of the user's request data.\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\n     * @return context value to send to a postOp\n     *      zero length to signify postOp is not required.\n     * @return validationData signature and time-range of this operation, encoded the same as the return value of validateUserOperation\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(UserOperation06 calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * post-operation handler.\n     * Must verify sender is the entryPoint\n     * @param mode enum with the following options:\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context - the context value returned by validatePaymasterUserOp\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     */\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external;\n}\n"
    },
    "contracts/legacy/v06/IStakeManager06.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * manage deposits and stakes.\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\n * stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager06 {\n\n    event Deposited(\n        address indexed account,\n        uint256 totalDeposit\n    );\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /// Emitted when stake or unstake delay are modified\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event StakeUnlocked(\n        address indexed account,\n        uint256 withdrawTime\n    );\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit the entity's deposit\n     * @param staked true if this entity is staked.\n     * @param stake actual amount of ether staked for this entity.\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\n     *    and the rest fit into a 2nd cell.\n     *    112 bit allows for 10^15 eth\n     *    48 bit for full timestamp\n     *    32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint112 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    //API struct used by getStakeInfo and simulateValidation\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /// @return info - full deposit information of given account\n    function getDepositInfo(address account) external view returns (DepositInfo memory info);\n\n    /// @return the deposit (for gas payment) of the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * attempt to unlock the stake.\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * withdraw from the (unlocked) stake.\n     * must first call unlockStake and wait for the unstakeDelay to pass\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * withdraw from the deposit.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\n}\n"
    },
    "contracts/legacy/v06/UserOperation06.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/**\n * User Operation struct\n * @param sender the sender account of this request.\n * @param nonce unique value the sender uses to verify it is not a replay.\n * @param initCode if set, the account contract will be created by this constructor/\n * @param callData the method call to execute on this account.\n * @param callGasLimit the gas limit passed to the callData method call.\n * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\n * @param maxFeePerGas same as EIP-1559 gas parameter.\n * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\n * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\n * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct UserOperation06 {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    uint256 callGasLimit;\n    uint256 verificationGasLimit;\n    uint256 preVerificationGas;\n    uint256 maxFeePerGas;\n    uint256 maxPriorityFeePerGas;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"
    },
    "contracts/samples/bls/BLSAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../SimpleAccount.sol\";\nimport \"./IBLSAccount.sol\";\n\n/**\n * Minimal BLS-based account that uses an aggregated signature.\n * The account must maintain its own BLS public key, and expose its trusted signature aggregator.\n * Note that unlike the \"standard\" SimpleAccount, this account can't be called directly\n * (normal SimpleAccount uses its \"signer\" address as both the ecrecover signer, and as a legitimate\n * Ethereum sender address. Obviously, a BLS public key is not a valid Ethereum sender address.)\n */\ncontract BLSAccount is SimpleAccount, IBLSAccount {\n    address public immutable aggregator;\n    uint256[4] private publicKey;\n\n    // The constructor is used only for the \"implementation\" and only sets immutable values.\n    // Mutable value slots for proxy accounts are set by the 'initialize' function.\n    constructor(IEntryPoint anEntryPoint, address anAggregator) SimpleAccount(anEntryPoint)  {\n        aggregator = anAggregator;\n    }\n\n    /**\n     * The initializer for the BLSAccount instance.\n     * @param aPublicKey public key from a BLS keypair that will have a full ownership and control of this account.\n     */\n    function initialize(uint256[4] memory aPublicKey) public virtual initializer {\n        super._initialize(address(0));\n        _setBlsPublicKey(aPublicKey);\n    }\n\n    function _validateSignature(PackedUserOperation calldata userOp, bytes32 userOpHash)\n    internal override view returns (uint256 validationData) {\n\n        (userOp, userOpHash);\n        if (userOp.initCode.length != 0) {\n            // BLSSignatureAggregator.getUserOpPublicKey() assumes that during account creation, the public key is\n            // the suffix of the initCode.\n            // The account MUST validate it\n            bytes32 pubKeyHash = keccak256(abi.encode(getBlsPublicKey()));\n            require(keccak256(userOp.initCode[userOp.initCode.length - 128 :]) == pubKeyHash, \"wrong pubkey\");\n        }\n        return _packValidationData(ValidationData(aggregator, 0,0));\n    }\n\n    /**\n     * Allows the owner to set or change the BLS key.\n     * @param newPublicKey public key from a BLS keypair that will have a full ownership and control of this account.\n     */\n    function setBlsPublicKey(uint256[4] memory newPublicKey) public onlyOwner {\n        _setBlsPublicKey(newPublicKey);\n    }\n\n    function _setBlsPublicKey(uint256[4] memory newPublicKey) internal {\n        emit PublicKeyChanged(publicKey, newPublicKey);\n        publicKey = newPublicKey;\n    }\n\n    /// @inheritdoc IBLSAccount\n    function getBlsPublicKey() public override view returns (uint256[4] memory) {\n        return publicKey;\n    }\n}\n"
    },
    "contracts/samples/bls/BLSAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport \"../../interfaces/IEntryPoint.sol\";\nimport \"./BLSAccount.sol\";\n\n/* solhint-disable no-inline-assembly */\n\n/**\n * Based on SimpleAccountFactory.\n * Cannot be a subclass since both constructor and createAccount depend on the\n * constructor and initializer of the actual account contract.\n */\ncontract BLSAccountFactory {\n    BLSAccount public immutable accountImplementation;\n\n    constructor(IEntryPoint entryPoint, address aggregator){\n        accountImplementation = new BLSAccount(entryPoint, aggregator);\n    }\n\n    /**\n     * create an account, and return its address.\n     * returns the address even if the account is already deployed.\n     * Note that during UserOperation execution, this method is called only if the account is not deployed.\n     * This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation\n     * Also note that our BLSSignatureAggregator requires that the public key is the last parameter\n     */\n    function createAccount(uint256 salt, uint256[4] calldata aPublicKey) public returns (BLSAccount) {\n\n        // the BLSSignatureAggregator depends on the public-key being the last 4 uint256 of msg.data.\n        uint slot;\n        assembly {slot := aPublicKey}\n        require(slot == msg.data.length - 128, \"wrong pubkey offset\");\n\n        address addr = getAddress(salt, aPublicKey);\n        uint codeSize = addr.code.length;\n        if (codeSize > 0) {\n            return BLSAccount(payable(addr));\n        }\n        return BLSAccount(payable(new ERC1967Proxy{salt : bytes32(salt)}(\n                address(accountImplementation),\n                abi.encodeCall(BLSAccount.initialize, aPublicKey)\n            )));\n    }\n\n    /**\n     * calculate the counterfactual address of this account as it would be returned by createAccount()\n     */\n    function getAddress(uint256 salt, uint256[4] memory aPublicKey) public view returns (address) {\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\n                type(ERC1967Proxy).creationCode,\n                abi.encode(\n                    address(accountImplementation),\n                    abi.encodeCall(BLSAccount.initialize, (aPublicKey))\n                )\n            )));\n    }\n}\n"
    },
    "contracts/samples/bls/BLSHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n// code taken from : https://github.com/witnet/elliptic-curve-solidity/blob/master/contracts/EllipticCurve.sol\n// missing core functions from \"thehubbleproject/bls\": jacAdd (and sum)\nlibrary  BLSHelper {\n\n    struct XY {\n        uint x;\n        uint y;\n    }\n    /**\n     * sum all the points in the array\n     * NOTE: the \"ecAdd\" (below) has a special case where x1==y2.\n     * @param points an array of bytes32[2], representing an (x,y) of a point\n     * @param _pp the modulus of the curve\n     * @return ret the sum of all points\n     */\n    function sum(XY[] memory points, uint256 _pp) internal pure returns (XY memory ret){\n        uint x = points[0].x;\n        uint y = points[0].y;\n        uint z = 1;\n\n        for (uint i = 1; i < points.length; i++) {\n            (x, y, z) = jacAdd(x, y, z, points[i].x, points[i].y, 1, _pp);\n        }\n        (x, y) = toAffine(x, y, z, _pp);\n        ret.x = x;\n        ret.y = y;\n    }\n\n    /// @dev Adds two points (x1, y1, z1) and (x2, y2, z2).\n    /// @param _x1 coordinate x of P1\n    /// @param _y1 coordinate y of P1\n    /// @param _z1 coordinate z of P1\n    /// @param _x2 coordinate x of square\n    /// @param _y2 coordinate y of square\n    /// @param _z2 coordinate z of square\n    /// @param _pp the modulus\n    /// @return (qx, qy, qz) P1+square in Jacobian\n    function jacAdd(\n        uint256 _x1,\n        uint256 _y1,\n        uint256 _z1,\n        uint256 _x2,\n        uint256 _y2,\n        uint256 _z2,\n        uint256 _pp)\n    internal pure returns (uint256, uint256, uint256)\n    {\n        if (_x1 == 0 && _y1 == 0)\n            return (_x2, _y2, _z2);\n        if (_x2 == 0 && _y2 == 0)\n            return (_x1, _y1, _z1);\n\n        // We follow the equations described in https://pdfs.semanticscholar.org/5c64/29952e08025a9649c2b0ba32518e9a7fb5c2.pdf Section 5\n        uint[4] memory zs;\n        // z1^2, z1^3, z2^2, z2^3\n        zs[0] = mulmod(_z1, _z1, _pp);\n        zs[1] = mulmod(_z1, zs[0], _pp);\n        zs[2] = mulmod(_z2, _z2, _pp);\n        zs[3] = mulmod(_z2, zs[2], _pp);\n\n        // u1, s1, u2, s2\n        zs = [\n        mulmod(_x1, zs[2], _pp),\n        mulmod(_y1, zs[3], _pp),\n        mulmod(_x2, zs[0], _pp),\n        mulmod(_y2, zs[1], _pp)\n        ];\n\n        // In case of zs[0] == zs[2] && zs[1] == zs[3], double function should be used\n        require(zs[0] != zs[2] || zs[1] != zs[3], \"Use jacDouble function instead\");\n\n        uint[4] memory hr;\n        //h\n        hr[0] = addmod(zs[2], _pp - zs[0], _pp);\n        //r\n        hr[1] = addmod(zs[3], _pp - zs[1], _pp);\n        //h^2\n        hr[2] = mulmod(hr[0], hr[0], _pp);\n        // h^3\n        hr[3] = mulmod(hr[2], hr[0], _pp);\n        // qx = -h^3  -2u1h^2+r^2\n        uint256 qx = addmod(mulmod(hr[1], hr[1], _pp), _pp - hr[3], _pp);\n        qx = addmod(qx, _pp - mulmod(2, mulmod(zs[0], hr[2], _pp), _pp), _pp);\n        // qy = -s1*z1*h^3+r(u1*h^2 -x^3)\n        uint256 qy = mulmod(hr[1], addmod(mulmod(zs[0], hr[2], _pp), _pp - qx, _pp), _pp);\n        qy = addmod(qy, _pp - mulmod(zs[1], hr[3], _pp), _pp);\n        // qz = h*z1*z2\n        uint256 qz = mulmod(hr[0], mulmod(_z1, _z2, _pp), _pp);\n        return (qx, qy, qz);\n    }\n\n\n    /// @dev Converts a point (x, y, z) expressed in Jacobian coordinates to affine coordinates (x', y', 1).\n    /// @param _x coordinate x\n    /// @param _y coordinate y\n    /// @param _z coordinate z\n    /// @param _pp the modulus\n    /// @return (x', y') affine coordinates\n    function toAffine(\n        uint256 _x,\n        uint256 _y,\n        uint256 _z,\n        uint256 _pp)\n    internal pure returns (uint256, uint256)\n    {\n        uint256 zInv = invMod(_z, _pp);\n        uint256 zInv2 = mulmod(zInv, zInv, _pp);\n        uint256 x2 = mulmod(_x, zInv2, _pp);\n        uint256 y2 = mulmod(_y, mulmod(zInv, zInv2, _pp), _pp);\n\n        return (x2, y2);\n    }\n\n\n    /// @dev Modular euclidean inverse of a number (mod p).\n    /// @param _x The number\n    /// @param _pp The modulus\n    /// @return q such that x*q = 1 (mod _pp)\n    function invMod(uint256 _x, uint256 _pp) internal pure returns (uint256) {\n        require(_x != 0 && _x != _pp && _pp != 0, \"Invalid number\");\n        uint256 q = 0;\n        uint256 newT = 1;\n        uint256 r = _pp;\n        uint256 t;\n        while (_x != 0) {\n            t = r / _x;\n            (q, newT) = (newT, addmod(q, (_pp - mulmod(t, newT, _pp)), _pp));\n            (r, _x) = (_x, r - t * _x);\n        }\n\n        return q;\n    }\n\n    /// @dev Doubles a point (x, y, z).\n    /// @param _x coordinate x of P1\n    /// @param _y coordinate y of P1\n    /// @param _z coordinate z of P1\n    /// @param _aa the a scalar in the curve equation\n    /// @param _pp the modulus\n    /// @return (qx, qy, qz) 2P in Jacobian\n    function jacDouble(\n        uint256 _x,\n        uint256 _y,\n        uint256 _z,\n        uint256 _aa,\n        uint256 _pp)\n    internal pure returns (uint256, uint256, uint256)\n    {\n        if (_z == 0)\n            return (_x, _y, _z);\n\n        // We follow the equations described in https://pdfs.semanticscholar.org/5c64/29952e08025a9649c2b0ba32518e9a7fb5c2.pdf Section 5\n        // Note: there is a bug in the paper regarding the m parameter, M=3*(x1^2)+a*(z1^4)\n        // x, y, z at this point represent the squares of _x, _y, _z\n        uint256 x = mulmod(_x, _x, _pp); //x1^2\n        uint256 y = mulmod(_y, _y, _pp); //y1^2\n        uint256 z = mulmod(_z, _z, _pp); //z1^2\n\n        // s\n        uint s = mulmod(4, mulmod(_x, y, _pp), _pp);\n        // m\n        uint m = addmod(mulmod(3, x, _pp), mulmod(_aa, mulmod(z, z, _pp), _pp), _pp);\n\n        // x, y, z at this point will be reassigned and rather represent qx, qy, qz from the paper\n        // This allows to reduce the gas cost and stack footprint of the algorithm\n        // qx\n        x = addmod(mulmod(m, m, _pp), _pp - addmod(s, s, _pp), _pp);\n        // qy = -8*y1^4 + M(S-T)\n        y = addmod(mulmod(m, addmod(s, _pp - x, _pp), _pp), _pp - mulmod(8, mulmod(y, y, _pp), _pp), _pp);\n        // qz = 2*y1*z1\n        z = mulmod(2, mulmod(_y, _z, _pp), _pp);\n\n        return (x, y, z);\n    }\n\n    /// @dev Add two points (x1, y1) and (x2, y2) in affine coordinates.\n    /// @param _x1 coordinate x of P1\n    /// @param _y1 coordinate y of P1\n    /// @param _x2 coordinate x of P2\n    /// @param _y2 coordinate y of P2\n    /// @param _aa constant of the curve\n    /// @param _pp the modulus\n    /// @return (qx, qy) = P1+P2 in affine coordinates\n    function ecAdd(\n        uint256 _x1,\n        uint256 _y1,\n        uint256 _x2,\n        uint256 _y2,\n        uint256 _aa,\n        uint256 _pp)\n    internal pure returns (uint256, uint256)\n    {\n        uint x = 0;\n        uint y = 0;\n        uint z = 0;\n\n        // Double if x1==x2 else add\n        if (_x1 == _x2) {\n            // y1 = -y2 mod p\n            if (addmod(_y1, _y2, _pp) == 0) {\n                return (0, 0);\n            } else {\n                // P1 = P2\n                (x, y, z) = jacDouble(\n                    _x1,\n                    _y1,\n                    1,\n                    _aa,\n                    _pp);\n            }\n        } else {\n            (x, y, z) = jacAdd(\n                _x1,\n                _y1,\n                1,\n                _x2,\n                _y2,\n                1,\n                _pp);\n        }\n        // Get back to affine\n        return toAffine(\n            x,\n            y,\n            z,\n            _pp);\n    }\n\n}\n"
    },
    "contracts/samples/bls/BLSSignatureAggregator.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4 <0.9.0;\npragma abicoder v2;\n\nimport \"../../interfaces/IAggregator.sol\";\nimport \"../../interfaces/IEntryPoint.sol\";\nimport \"../../core/UserOperationLib.sol\";\nimport {BLSOpen} from  \"./lib/BLSOpen.sol\";\nimport \"./IBLSAccount.sol\";\nimport \"./BLSHelper.sol\";\n\n/**\n * A BLS-based signature aggregator, to validate aggregated signature of multiple UserOps if BLSAccount\n */\ncontract BLSSignatureAggregator is IAggregator {\n    using UserOperationLib for PackedUserOperation;\n\n    bytes32 public constant BLS_DOMAIN = keccak256(\"eip4337.bls.domain\");\n\n     //copied from BLS.sol\n    uint256 public  constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    address public immutable entryPoint;\n\n    constructor(address _entryPoint) {\n        entryPoint = _entryPoint;\n    }\n\n    /**\n     * @return publicKey - the public key from a BLS keypair the Aggregator will use to verify this UserOp;\n     *         normally public key will be queried from the deployed BLSAccount itself;\n     *         the public key will be read from the 'initCode' if the account is not deployed yet;\n     */\n    function getUserOpPublicKey(PackedUserOperation memory userOp) public view returns (uint256[4] memory publicKey) {\n        bytes memory initCode = userOp.initCode;\n        if (initCode.length > 0) {\n            publicKey = getTrailingPublicKey(initCode);\n        } else {\n            return IBLSAccount(userOp.sender).getBlsPublicKey{gas : 50000}();\n        }\n    }\n\n    /**\n     * return the trailing 4 words of input data\n     */\n    function getTrailingPublicKey(bytes memory data) public pure returns (uint256[4] memory publicKey) {\n        uint len = data.length;\n        require(len > 32 * 4, \"data too short for sig\");\n\n        /* solhint-disable-next-line no-inline-assembly */\n        assembly {\n        // actual buffer starts at data+32, so last 128 bytes start at data+32+len-128 = data+len-96\n            let ofs := sub(add(data, len), 96)\n            mstore(publicKey, mload(ofs))\n            mstore(add(publicKey, 32), mload(add(ofs, 32)))\n            mstore(add(publicKey, 64), mload(add(ofs, 64)))\n            mstore(add(publicKey, 96), mload(add(ofs, 96)))\n        }\n    }\n\n    /// @inheritdoc IAggregator\n    function validateSignatures(PackedUserOperation[] calldata userOps, bytes calldata signature)\n    external view override {\n        require(signature.length == 64, \"BLS: invalid signature\");\n        (uint256[2] memory blsSignature) = abi.decode(signature, (uint256[2]));\n\n        uint userOpsLen = userOps.length;\n        uint256[4][] memory blsPublicKeys = new uint256[4][](userOpsLen);\n        uint256[2][] memory messages = new uint256[2][](userOpsLen);\n        for (uint256 i = 0; i < userOpsLen; i++) {\n\n            PackedUserOperation memory userOp = userOps[i];\n            blsPublicKeys[i] = getUserOpPublicKey(userOp);\n\n            messages[i] = _userOpToMessage(userOp, _getPublicKeyHash(blsPublicKeys[i]));\n        }\n        require(BLSOpen.verifyMultiple(blsSignature, blsPublicKeys, messages), \"BLS: validateSignatures failed\");\n    }\n\n    /**\n     * get a hash of userOp\n     * NOTE: this hash is not the same as UserOperation.hash()\n     *  (slightly less efficient, since it uses memory userOp)\n     */\n    function internalUserOpHash(PackedUserOperation memory userOp) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                userOp.sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.accountGasLimits,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas,\n                keccak256(userOp.paymasterAndData)\n            ));\n    }\n\n    /**\n     * return the BLS \"message\" for the given UserOp.\n     * the account checks the signature over this value using its public key\n     */\n    function userOpToMessage(PackedUserOperation memory userOp) public view returns (uint256[2] memory) {\n        bytes32 publicKeyHash = _getPublicKeyHash(getUserOpPublicKey(userOp));\n        return _userOpToMessage(userOp, publicKeyHash);\n    }\n\n    function _userOpToMessage(PackedUserOperation memory userOp, bytes32 publicKeyHash) internal view returns (uint256[2] memory) {\n        bytes32 userOpHash = _getUserOpHash(userOp, publicKeyHash);\n        return BLSOpen.hashToPoint(BLS_DOMAIN, abi.encodePacked(userOpHash));\n    }\n\n    function getUserOpHash(PackedUserOperation memory userOp) public view returns (bytes32) {\n        bytes32 publicKeyHash = _getPublicKeyHash(getUserOpPublicKey(userOp));\n        return _getUserOpHash(userOp, publicKeyHash);\n    }\n\n    function _getUserOpHash(PackedUserOperation memory userOp, bytes32 publicKeyHash) internal view returns (bytes32) {\n        return keccak256(abi.encode(internalUserOpHash(userOp), publicKeyHash, address(this), block.chainid, entryPoint));\n    }\n\n    function _getPublicKeyHash(uint256[4] memory publicKey) internal pure returns(bytes32) {\n        return keccak256(abi.encode(publicKey));\n    }\n    /**\n     * validate signature of a single userOp\n     * This method is called after EntryPoint.simulateValidation() returns an aggregator.\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(PackedUserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp) {\n        uint256[2] memory signature = abi.decode(userOp.signature, (uint256[2]));\n        uint256[4] memory pubkey = getUserOpPublicKey(userOp);\n        uint256[2] memory message = _userOpToMessage(userOp, _getPublicKeyHash(pubkey));\n\n        require(BLSOpen.verifySingle(signature, pubkey, message), \"BLS: wrong sig\");\n        return \"\";\n    }\n\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature the aggregated signature\n     */\n    function aggregateSignatures(PackedUserOperation[] calldata userOps) external pure returns (bytes memory aggregatedSignature) {\n        BLSHelper.XY[] memory points = new BLSHelper.XY[](userOps.length);\n        for (uint i = 0; i < points.length; i++) {\n            (uint256 x, uint256 y) = abi.decode(userOps[i].signature, (uint256, uint256));\n            points[i] = BLSHelper.XY(x, y);\n        }\n        BLSHelper.XY memory sum = BLSHelper.sum(points, N);\n        return abi.encode(sum.x, sum.y);\n    }\n\n    /**\n     * allow staking for this aggregator\n     * there is no limit on stake or delay, but it is not a problem, since it is a permissionless\n     * signature aggregator, which doesn't support unstaking.\n     */\n    function addStake(uint32 delay) external payable {\n        IEntryPoint(entryPoint).addStake{value : msg.value}(delay);\n    }\n}\n"
    },
    "contracts/samples/bls/IBLSAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.6;\n\nimport \"../../interfaces/IAccount.sol\";\n\n/**\n * a BLS account should expose its own public key.\n */\ninterface IBLSAccount is IAccount {\n    event PublicKeyChanged(uint256[4] oldPublicKey, uint256[4] newPublicKey);\n\n    /**\n     * @return public key from a BLS keypair that is used to verify the BLS signature, both separately and aggregated.\n     */\n    function getBlsPublicKey() external view returns (uint256[4] memory);\n}\n"
    },
    "contracts/samples/bls/lib/BLSOpen.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\n\nimport { BLS } from \"./hubble-contracts/contracts/libs/BLS.sol\";\n\nlibrary BLSOpen {\n    function verifySingle(\n        uint256[2] memory signature,\n        uint256[4] memory pubkey,\n        uint256[2] memory message\n    ) external view returns (bool) {\n        uint256[4][] memory pubkeys = new uint256[4][](1);\n        uint256[2][] memory messages = new uint256[2][](1);\n        pubkeys[0] = pubkey;\n        messages[0] = message;\n\n        (bool verified, bool callSuccess) =  BLS.verifyMultiple(\n            signature,\n            pubkeys,\n            messages\n        );\n        return callSuccess && verified;\n\n        // // NB: (result, success) opposite of `call` convention (success, result).\n        // (bool verified, bool callSuccess) = BLS.verifySingle(\n        //     signature,\n        //     pubkey,\n        //     message\n        // );\n        // return callSuccess && verified;\n    }\n\n    function verifyMultiple(\n        uint256[2] memory signature,\n        uint256[4][] memory pubkeys,\n        uint256[2][] memory messages\n    ) external view returns (bool) {\n        (bool verified, bool callSuccess) =  BLS.verifyMultiple(\n            signature,\n            pubkeys,\n            messages\n        );\n        return callSuccess && verified;\n    }\n\n    function hashToPoint(\n        bytes32 domain,\n        bytes memory message\n    ) external view returns (uint256[2] memory) {\n        return BLS.hashToPoint(\n            domain,\n            message\n        );\n    }\n\n    function isZeroBLSKey(uint256[4] memory blsKey) public pure returns (bool) {\n        bool isZero = true;\n        for (uint256 i=0; isZero && i<4; i++) {\n            isZero = (blsKey[i] == 0);\n        }\n        return isZero;\n    }\n\n}\n"
    },
    "contracts/samples/bls/lib/hubble-contracts/contracts/libs/BLS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\n\nimport { ModexpInverse, ModexpSqrt } from \"./ModExp.sol\";\nimport {\n    BNPairingPrecompileCostEstimator\n} from \"./BNPairingPrecompileCostEstimator.sol\";\n\n/**\n    @title  Boneh–Lynn–Shacham (BLS) signature scheme on Barreto-Naehrig 254 bit curve (BN-254)\n    @notice We use BLS signature aggregation to reduce the size of signature data to store on chain.\n    @dev We use G1 points for signatures and messages, and G2 points for public keys\n */\nlibrary BLS {\n    // Field order\n    // prettier-ignore\n    uint256 private constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Negated genarator of G2\n    // prettier-ignore\n    uint256 private constant N_G2_X1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    // prettier-ignore\n    uint256 private constant N_G2_X0 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    // prettier-ignore\n    uint256 private constant N_G2_Y1 = 17805874995975841540914202342111839520379459829704422454583296818431106115052;\n    // prettier-ignore\n    uint256 private constant N_G2_Y0 = 13392588948715843804641432497768002650278120570034223513918757245338268106653;\n\n    // sqrt(-3)\n    // prettier-ignore\n    uint256 private constant Z0 = 0x0000000000000000b3c4d79d41a91759a9e4c7e359b6b89eaec68e62effffffd;\n    // (sqrt(-3) - 1)  / 2\n    // prettier-ignore\n    uint256 private constant Z1 = 0x000000000000000059e26bcea0d48bacd4f263f1acdb5c4f5763473177fffffe;\n\n    // prettier-ignore\n    uint256 private constant T24 = 0x1000000000000000000000000000000000000000000000000;\n    // prettier-ignore\n    uint256 private constant MASK24 = 0xffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    // estimator address\n//    address private constant COST_ESTIMATOR_ADDRESS =  new 0x22E4a5251C1F02de8369Dd6f192033F6CB7531A4;\n\n    function verifySingle(\n        uint256[2] memory signature,\n        uint256[4] memory pubkey,\n        uint256[2] memory message\n    ) internal view returns (bool, bool) {\n        uint256[12] memory input =\n            [\n                signature[0],\n                signature[1],\n                N_G2_X1,\n                N_G2_X0,\n                N_G2_Y1,\n                N_G2_Y0,\n                message[0],\n                message[1],\n                pubkey[1],\n                pubkey[0],\n                pubkey[3],\n                pubkey[2]\n            ];\n        uint256[1] memory out;\n        uint256 precompileGasCost = gasleft();\n//            BNPairingPrecompileCostEstimator(COST_ESTIMATOR_ADDRESS).getGasCost(\n//                2\n//            );\n        bool callSuccess;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            callSuccess := staticcall(\n                precompileGasCost,\n                8,\n                input,\n                384,\n                out,\n                0x20\n            )\n        }\n        if (!callSuccess) {\n            return (false, false);\n        }\n        return (out[0] != 0, true);\n    }\n\n    function verifyMultiple(\n        uint256[2] memory signature,\n        uint256[4][] memory pubkeys,\n        uint256[2][] memory messages\n    ) internal view returns (bool checkResult, bool callSuccess) {\n        uint256 size = pubkeys.length;\n        require(size > 0, \"BLS: number of public key is zero\");\n        require(\n            size == messages.length,\n            \"BLS: number of public keys and messages must be equal\"\n        );\n        uint256 inputSize = (size + 1) * 6;\n        uint256[] memory input = new uint256[](inputSize);\n        input[0] = signature[0];\n        input[1] = signature[1];\n        input[2] = N_G2_X1;\n        input[3] = N_G2_X0;\n        input[4] = N_G2_Y1;\n        input[5] = N_G2_Y0;\n        for (uint256 i = 0; i < size; i++) {\n            input[i * 6 + 6] = messages[i][0];\n            input[i * 6 + 7] = messages[i][1];\n            input[i * 6 + 8] = pubkeys[i][1];\n            input[i * 6 + 9] = pubkeys[i][0];\n            input[i * 6 + 10] = pubkeys[i][3];\n            input[i * 6 + 11] = pubkeys[i][2];\n        }\n        uint256[1] memory out;\n\n        // prettier-ignore\n        uint256 precompileGasCost = gasleft();\n//        uint256 precompileGasCost = BNPairingPrecompileCostEstimator(COST_ESTIMATOR_ADDRESS).getGasCost(size + 1);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            callSuccess := staticcall(\n                precompileGasCost,\n                8,\n                add(input, 0x20),\n                mul(inputSize, 0x20),\n                out,\n                0x20\n            )\n        }\n        if (!callSuccess) {\n            return (false, false);\n        }\n        return (out[0] != 0, true);\n    }\n\n    /**\n    @notice Fouque-Tibouchi Hash to Curve\n     */\n    function hashToPoint(bytes32 domain, bytes memory message)\n        internal\n        view\n        returns (uint256[2] memory)\n    {\n        uint256[2] memory u = hashToField(domain, message);\n        uint256[2] memory p0 = mapToPoint(u[0]);\n        uint256[2] memory p1 = mapToPoint(u[1]);\n        uint256[4] memory bnAddInput;\n        bnAddInput[0] = p0[0];\n        bnAddInput[1] = p0[1];\n        bnAddInput[2] = p1[0];\n        bnAddInput[3] = p1[1];\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, bnAddInput, 128, p0, 64)\n            switch success\n                case 0 {\n                    invalid()\n                }\n        }\n        require(success, \"BLS: bn add call failed\");\n        return p0;\n    }\n\n    function mapToPoint(uint256 _x)\n        internal\n        pure\n        returns (uint256[2] memory p)\n    {\n        require(_x < N, \"mapToPointFT: invalid field element\");\n        uint256 x = _x;\n\n        (, bool decision) = sqrt(x);\n\n        uint256 a0 = mulmod(x, x, N);\n        a0 = addmod(a0, 4, N);\n        uint256 a1 = mulmod(x, Z0, N);\n        uint256 a2 = mulmod(a1, a0, N);\n        a2 = inverse(a2);\n        a1 = mulmod(a1, a1, N);\n        a1 = mulmod(a1, a2, N);\n\n        // x1\n        a1 = mulmod(x, a1, N);\n        x = addmod(Z1, N - a1, N);\n        // check curve\n        a1 = mulmod(x, x, N);\n        a1 = mulmod(a1, x, N);\n        a1 = addmod(a1, 3, N);\n        bool found;\n        (a1, found) = sqrt(a1);\n        if (found) {\n            if (!decision) {\n                a1 = N - a1;\n            }\n            return [x, a1];\n        }\n\n        // x2\n        x = N - addmod(x, 1, N);\n        // check curve\n        a1 = mulmod(x, x, N);\n        a1 = mulmod(a1, x, N);\n        a1 = addmod(a1, 3, N);\n        (a1, found) = sqrt(a1);\n        if (found) {\n            if (!decision) {\n                a1 = N - a1;\n            }\n            return [x, a1];\n        }\n\n        // x3\n        x = mulmod(a0, a0, N);\n        x = mulmod(x, x, N);\n        x = mulmod(x, a2, N);\n        x = mulmod(x, a2, N);\n        x = addmod(x, 1, N);\n        // must be on curve\n        a1 = mulmod(x, x, N);\n        a1 = mulmod(a1, x, N);\n        a1 = addmod(a1, 3, N);\n        (a1, found) = sqrt(a1);\n        require(found, \"BLS: bad ft mapping implementation\");\n        if (!decision) {\n            a1 = N - a1;\n        }\n        return [x, a1];\n    }\n\n    function isValidSignature(uint256[2] memory signature)\n        internal\n        pure\n        returns (bool)\n    {\n        if ((signature[0] >= N) || (signature[1] >= N)) {\n            return false;\n        } else {\n            return isOnCurveG1(signature);\n        }\n    }\n\n    function isOnCurveG1(uint256[2] memory point)\n        internal\n        pure\n        returns (bool _isOnCurve)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let t0 := mload(point)\n            let t1 := mload(add(point, 32))\n            let t2 := mulmod(t0, t0, N)\n            t2 := mulmod(t2, t0, N)\n            t2 := addmod(t2, 3, N)\n            t1 := mulmod(t1, t1, N)\n            _isOnCurve := eq(t1, t2)\n        }\n    }\n\n    function isOnCurveG2(uint256[4] memory point)\n        internal\n        pure\n        returns (bool _isOnCurve)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // x0, x1\n            let t0 := mload(point)\n            let t1 := mload(add(point, 32))\n            // x0 ^ 2\n            let t2 := mulmod(t0, t0, N)\n            // x1 ^ 2\n            let t3 := mulmod(t1, t1, N)\n            // 3 * x0 ^ 2\n            let t4 := add(add(t2, t2), t2)\n            // 3 * x1 ^ 2\n            let t5 := addmod(add(t3, t3), t3, N)\n            // x0 * (x0 ^ 2 - 3 * x1 ^ 2)\n            t2 := mulmod(add(t2, sub(N, t5)), t0, N)\n            // x1 * (3 * x0 ^ 2 - x1 ^ 2)\n            t3 := mulmod(add(t4, sub(N, t3)), t1, N)\n\n            // x ^ 3 + b\n            t0 := addmod(\n                t2,\n                0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5,\n                N\n            )\n            t1 := addmod(\n                t3,\n                0x009713b03af0fed4cd2cafadeed8fdf4a74fa084e52d1852e4a2bd0685c315d2,\n                N\n            )\n\n            // y0, y1\n            t2 := mload(add(point, 64))\n            t3 := mload(add(point, 96))\n            // y ^ 2\n            t4 := mulmod(addmod(t2, t3, N), addmod(t2, sub(N, t3), N), N)\n            t3 := mulmod(shl(1, t2), t3, N)\n\n            // y ^ 2 == x ^ 3 + b\n            _isOnCurve := and(eq(t0, t4), eq(t1, t3))\n        }\n    }\n\n    function sqrt(uint256 xx) internal pure returns (uint256 x, bool hasRoot) {\n        x = ModexpSqrt.run(xx);\n        hasRoot = mulmod(x, x, N) == xx;\n    }\n\n    function inverse(uint256 a) internal pure returns (uint256) {\n        return ModexpInverse.run(a);\n    }\n\n    function hashToField(bytes32 domain, bytes memory messages)\n        internal\n        pure\n        returns (uint256[2] memory)\n    {\n        bytes memory _msg = expandMsgTo96(domain, messages);\n        uint256 u0;\n        uint256 u1;\n        uint256 a0;\n        uint256 a1;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let p := add(_msg, 24)\n            u1 := and(mload(p), MASK24)\n            p := add(_msg, 48)\n            u0 := and(mload(p), MASK24)\n            a0 := addmod(mulmod(u1, T24, N), u0, N)\n            p := add(_msg, 72)\n            u1 := and(mload(p), MASK24)\n            p := add(_msg, 96)\n            u0 := and(mload(p), MASK24)\n            a1 := addmod(mulmod(u1, T24, N), u0, N)\n        }\n        return [a0, a1];\n    }\n\n    function expandMsgTo96(bytes32 domain, bytes memory message)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        // zero<64>|msg<var>|lib_str<2>|I2OSP(0, 1)<1>|dst<var>|dst_len<1>\n        uint256 t0 = message.length;\n        bytes memory msg0 = new bytes(32 + t0 + 64 + 4);\n        bytes memory out = new bytes(96);\n        // b0\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let p := add(msg0, 96)\n            for {\n                let z := 0\n            } lt(z, t0) {\n                z := add(z, 32)\n            } {\n                mstore(add(p, z), mload(add(message, add(z, 32))))\n            }\n            p := add(p, t0)\n\n            mstore8(p, 0)\n            p := add(p, 1)\n            mstore8(p, 96)\n            p := add(p, 1)\n            mstore8(p, 0)\n            p := add(p, 1)\n\n            mstore(p, domain)\n            p := add(p, 32)\n            mstore8(p, 32)\n        }\n        bytes32 b0 = sha256(msg0);\n        bytes32 bi;\n        t0 = 32 + 34;\n\n        // resize intermediate message\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(msg0, t0)\n        }\n\n        // b1\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(add(msg0, 32), b0)\n            mstore8(add(msg0, 64), 1)\n            mstore(add(msg0, 65), domain)\n            mstore8(add(msg0, add(32, 65)), 32)\n        }\n\n        bi = sha256(msg0);\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(add(out, 32), bi)\n        }\n\n        // b2\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let t := xor(b0, bi)\n            mstore(add(msg0, 32), t)\n            mstore8(add(msg0, 64), 2)\n            mstore(add(msg0, 65), domain)\n            mstore8(add(msg0, add(32, 65)), 32)\n        }\n\n        bi = sha256(msg0);\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(add(out, 64), bi)\n        }\n\n        // b3\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let t := xor(b0, bi)\n            mstore(add(msg0, 32), t)\n            mstore8(add(msg0, 64), 3)\n            mstore(add(msg0, 65), domain)\n            mstore8(add(msg0, add(32, 65)), 32)\n        }\n\n        bi = sha256(msg0);\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(add(out, 96), bi)\n        }\n\n        return out;\n    }\n}\n"
    },
    "contracts/samples/bls/lib/hubble-contracts/contracts/libs/BNPairingPrecompileCostEstimator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\ncontract BNPairingPrecompileCostEstimator {\n    uint256 public baseCost;\n    uint256 public perPairCost;\n\n    // G1 Generator\n    uint256 private constant G1_X = 1;\n    uint256 private constant G1_Y = 2;\n\n    // G2 genarator\n    // prettier-ignore\n    uint256 private constant G2_X0 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    // prettier-ignore\n    uint256 private constant G2_X1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    // prettier-ignore\n    uint256 private constant G2_Y0 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    // prettier-ignore\n    uint256 private constant G2_Y1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n\n    // G2 negated genarator y coordinates\n    // prettier-ignore\n    uint256 private constant N_G2_Y0 = 13392588948715843804641432497768002650278120570034223513918757245338268106653;\n    // prettier-ignore\n    uint256 private constant N_G2_Y1 = 17805874995975841540914202342111839520379459829704422454583296818431106115052;\n\n    function run() external {\n        _run();\n    }\n\n    function getGasCost(uint256 pairCount) external view returns (uint256) {\n        return pairCount * perPairCost + baseCost;\n    }\n\n    function _run() internal {\n        uint256 gasCost1Pair = _gasCost1Pair();\n        uint256 gasCost2Pair = _gasCost2Pair();\n        perPairCost = gasCost2Pair - gasCost1Pair;\n        baseCost = gasCost1Pair - perPairCost;\n    }\n\n    function _gasCost1Pair() internal view returns (uint256) {\n        uint256[6] memory input = [G1_X, G1_Y, G2_X1, G2_X0, G2_Y1, G2_Y0];\n        uint256[1] memory out;\n        bool callSuccess;\n        uint256 suppliedGas = gasleft() - 2000;\n        require(\n            gasleft() > 2000,\n            \"BNPairingPrecompileCostEstimator: not enough gas, single pair\"\n        );\n        uint256 gasT0 = gasleft();\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            callSuccess := staticcall(suppliedGas, 8, input, 192, out, 0x20)\n        }\n        uint256 gasCost = gasT0 - gasleft();\n        require(\n            callSuccess,\n            \"BNPairingPrecompileCostEstimator: single pair call is failed\"\n        );\n        require(\n            out[0] == 0,\n            \"BNPairingPrecompileCostEstimator: single pair call result must be 0\"\n        );\n        return gasCost;\n    }\n\n    function _gasCost2Pair() internal view returns (uint256) {\n        uint256[12] memory input =\n            [\n                G1_X,\n                G1_Y,\n                G2_X1,\n                G2_X0,\n                G2_Y1,\n                G2_Y0,\n                G1_X,\n                G1_Y,\n                G2_X1,\n                G2_X0,\n                N_G2_Y1,\n                N_G2_Y0\n            ];\n        uint256[1] memory out;\n        bool callSuccess;\n        uint256 suppliedGas = gasleft() - 2000;\n        require(\n            gasleft() > 2000,\n            \"BNPairingPrecompileCostEstimator: not enough gas, couple pair\"\n        );\n        uint256 gasT0 = gasleft();\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            callSuccess := staticcall(suppliedGas, 8, input, 384, out, 0x20)\n        }\n        uint256 gasCost = gasT0 - gasleft();\n        require(\n            callSuccess,\n            \"BNPairingPrecompileCostEstimator: couple pair call is failed\"\n        );\n        require(\n            out[0] == 1,\n            \"BNPairingPrecompileCostEstimator: couple pair call result must be 1\"\n        );\n        return gasCost;\n    }\n}\n"
    },
    "contracts/samples/bls/lib/hubble-contracts/contracts/libs/ModExp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\n\n/**\n    @title Compute Inverse by Modular Exponentiation\n    @notice Compute $input^(N - 2) mod N$ using Addition Chain method.\n    Where     N = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n    and   N - 2 = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd45\n    @dev the function body is generated with the modified addchain script\n    see https://github.com/kobigurk/addchain/commit/2c37a2ace567a9bdc680b4e929c94aaaa3ec700f\n */\nlibrary ModexpInverse {\n    function run(uint256 t2) internal pure returns (uint256 t0) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let\n                n\n            := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n            t0 := mulmod(t2, t2, n)\n            let t5 := mulmod(t0, t2, n)\n            let t1 := mulmod(t5, t0, n)\n            let t3 := mulmod(t5, t5, n)\n            let t8 := mulmod(t1, t0, n)\n            let t4 := mulmod(t3, t5, n)\n            let t6 := mulmod(t3, t1, n)\n            t0 := mulmod(t3, t3, n)\n            let t7 := mulmod(t8, t3, n)\n            t3 := mulmod(t4, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n        }\n    }\n}\n\n/**\n    @title Compute Squre Root by Modular Exponentiation\n    @notice Compute $input^{(N + 1) / 4} mod N$ using Addition Chain method.\n    Where           N = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n    and   (N + 1) / 4 = 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52\n */\nlibrary ModexpSqrt {\n    function run(uint256 t6) internal pure returns (uint256 t0) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let\n                n\n            := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n            t0 := mulmod(t6, t6, n)\n            let t4 := mulmod(t0, t6, n)\n            let t2 := mulmod(t4, t0, n)\n            let t3 := mulmod(t4, t4, n)\n            let t8 := mulmod(t2, t0, n)\n            let t1 := mulmod(t3, t4, n)\n            let t5 := mulmod(t3, t2, n)\n            t0 := mulmod(t3, t3, n)\n            let t7 := mulmod(t8, t3, n)\n            t3 := mulmod(t1, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n        }\n    }\n}\n"
    },
    "contracts/samples/callback/TokenCallbackHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable no-empty-blocks */\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\n\n/**\n * Token callback handler.\n *   Handles supported tokens' callbacks, allowing account receiving these tokens.\n */\nabstract contract TokenCallbackHandler is IERC721Receiver, IERC1155Receiver {\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC1155Receiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\n    }\n\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC721Receiver).interfaceId ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/samples/IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\ninterface IOracle {\n\n    /**\n     * return amount of tokens that are required to receive that much eth.\n     */\n    function getTokenValueOfEth(uint256 ethOutput) external view returns (uint256 tokenInput);\n}\n\n"
    },
    "contracts/samples/LegacyTokenPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../core/BasePaymaster.sol\";\nimport \"../core/UserOperationLib.sol\";\n\n/**\n * A sample paymaster that defines itself as a token to pay for gas.\n * The paymaster IS the token to use, since a paymaster cannot use an external contract.\n * Also, the exchange rate has to be fixed, since it can't reference an external Uniswap or other exchange contract.\n * subclass should override \"getTokenValueOfEth\" to provide actual token exchange rate, settable by the owner.\n * Known Limitation: this paymaster is exploitable when put into a batch with multiple ops (of different accounts):\n * - while a single op can't exploit the paymaster (if postOp fails to withdraw the tokens, the user's op is reverted,\n *   and then we know we can withdraw the tokens), multiple ops with different senders (all using this paymaster)\n *   in a batch can withdraw funds from 2nd and further ops, forcing the paymaster itself to pay (from its deposit)\n * - Possible workarounds are either use a more complex paymaster scheme (e.g. the DepositPaymaster) or\n *   to whitelist the account and the called method ids.\n */\ncontract LegacyTokenPaymaster is BasePaymaster, ERC20 {\n\n    //calculated cost of the postOp\n    uint256 constant public COST_OF_POST = 15000;\n\n    address public immutable theFactory;\n\n    constructor(address accountFactory, string memory _symbol, IEntryPoint _entryPoint) ERC20(_symbol, _symbol) BasePaymaster(_entryPoint) {\n        theFactory = accountFactory;\n        //make it non-empty\n        _mint(address(this), 1);\n\n        //owner is allowed to withdraw tokens from the paymaster's balance\n        _approve(address(this), msg.sender, type(uint).max);\n    }\n\n\n    /**\n     * helpers for owner, to mint and withdraw tokens.\n     * @param recipient - the address that will receive the minted tokens.\n     * @param amount - the amount it will receive.\n     */\n    function mintTokens(address recipient, uint256 amount) external onlyOwner {\n        _mint(recipient, amount);\n    }\n\n    /**\n     * transfer paymaster ownership.\n     * owner of this paymaster is allowed to withdraw funds (tokens transferred to this paymaster's balance)\n     * when changing owner, the old owner's withdrawal rights are revoked.\n     */\n    function transferOwnership(address newOwner) public override virtual onlyOwner {\n        // remove allowance of current owner\n        _approve(address(this), owner(), 0);\n        super.transferOwnership(newOwner);\n        // new owner is allowed to withdraw tokens from the paymaster's balance\n        _approve(address(this), newOwner, type(uint).max);\n    }\n\n    //Note: this method assumes a fixed ratio of token-to-eth. subclass should override to supply oracle\n    // or a setter.\n    function getTokenValueOfEth(uint256 valueEth) internal view virtual returns (uint256 valueToken) {\n        return valueEth / 100;\n    }\n\n    /**\n      * validate the request:\n      * if this is a constructor call, make sure it is a known account.\n      * verify the sender has enough tokens.\n      * (since the paymaster is also the token, there is no notion of \"approval\")\n      */\n    function _validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n    internal view override returns (bytes memory context, uint256 validationData) {\n        uint256 tokenPrefund = getTokenValueOfEth(requiredPreFund);\n\n        (,,uint256 postOpGasLimit) = UserOperationLib.unpackPaymasterStaticFields(userOp.paymasterAndData);\n        require( postOpGasLimit > COST_OF_POST, \"TokenPaymaster: gas too low for postOp\");\n\n        if (userOp.initCode.length != 0) {\n            _validateConstructor(userOp);\n            require(balanceOf(userOp.sender) >= tokenPrefund, \"TokenPaymaster: no balance (pre-create)\");\n        } else {\n\n            require(balanceOf(userOp.sender) >= tokenPrefund, \"TokenPaymaster: no balance\");\n        }\n\n        return (abi.encode(userOp.sender), 0);\n    }\n\n    // when constructing an account, validate constructor code and parameters\n    // we trust our factory (and that it doesn't have any other public methods)\n    function _validateConstructor(PackedUserOperation calldata userOp) internal virtual view {\n        address factory = address(bytes20(userOp.initCode[0 : 20]));\n        require(factory == theFactory, \"TokenPaymaster: wrong account factory\");\n    }\n\n    /**\n     * actual charge of user.\n     * this method will be called just after the user's TX with mode==OpSucceeded|OpReverted (account pays in both cases)\n     * BUT: if the user changed its balance in a way that will cause  postOp to revert, then it gets called again, after reverting\n     * the user's TX , back to the state it was before the transaction started (before the validatePaymasterUserOp),\n     * and the transaction should succeed there.\n     */\n    function _postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost, uint actualUserOpFeePerGas) internal override {\n        //we don't really care about the mode, we just pay the gas with the user's tokens.\n        (mode);\n        address sender = abi.decode(context, (address));\n        uint256 charge = getTokenValueOfEth(actualGasCost + COST_OF_POST * actualUserOpFeePerGas);\n        //actualGasCost is known to be no larger than the above requiredPreFund, so the transfer should succeed.\n        _transfer(sender, address(this), charge);\n    }\n}\n"
    },
    "contracts/samples/SimpleAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"../core/BaseAccount.sol\";\nimport \"./callback/TokenCallbackHandler.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n  * minimal account.\n  *  this is sample minimal account.\n  *  has execute, eth handling methods\n  *  has a single signer that can send requests through the entryPoint.\n  */\ncontract SimpleAccount is BaseAccount, TokenCallbackHandler, UUPSUpgradeable, Initializable {\n    address public owner;\n\n    IEntryPoint private immutable _entryPoint;\n\n    event SimpleAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    modifier onlyOwner() {\n        _onlyOwner();\n        _;\n    }\n\n    /// @inheritdoc BaseAccount\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    constructor(IEntryPoint anEntryPoint) {\n        _entryPoint = anEntryPoint;\n        _disableInitializers();\n    }\n\n    function _onlyOwner() internal view {\n        //directly from EOA owner, or through the account itself (which gets redirected through execute())\n        require(msg.sender == owner || msg.sender == address(this), \"only owner\");\n    }\n\n    /**\n     * execute a transaction (called directly from owner, or by entryPoint)\n     */\n    function execute(address dest, uint256 value, bytes calldata func) external {\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    /**\n     * execute a sequence of transactions\n     * @dev to reduce gas consumption for trivial case (no value), use a zero-length array to mean zero value\n     */\n    function executeBatch(address[] calldata dest, uint256[] calldata value, bytes[] calldata func) external {\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length && (value.length == 0 || value.length == func.length), \"wrong array lengths\");\n        if (value.length == 0) {\n            for (uint256 i = 0; i < dest.length; i++) {\n                _call(dest[i], 0, func[i]);\n            }\n        } else {\n            for (uint256 i = 0; i < dest.length; i++) {\n                _call(dest[i], value[i], func[i]);\n            }\n        }\n    }\n\n    /**\n     * @dev The _entryPoint member is immutable, to reduce gas consumption.  To upgrade EntryPoint,\n     * a new implementation of SimpleAccount must be deployed with the new EntryPoint address, then upgrading\n      * the implementation by calling `upgradeTo()`\n     */\n    function initialize(address anOwner) public virtual initializer {\n        _initialize(anOwner);\n    }\n\n    function _initialize(address anOwner) internal virtual {\n        owner = anOwner;\n        emit SimpleAccountInitialized(_entryPoint, owner);\n    }\n\n    // Require the function call went through EntryPoint or owner\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(PackedUserOperation calldata userOp, bytes32 userOpHash)\n    internal override virtual returns (uint256 validationData) {\n        bytes32 hash = MessageHashUtils.toEthSignedMessageHash(userOpHash);\n        if (owner != ECDSA.recover(hash, userOp.signature))\n            return SIG_VALIDATION_FAILED;\n        return 0;\n    }\n\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value: value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n        entryPoint().depositTo{value: msg.value}(address(this));\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        _onlyOwner();\n    }\n}\n\n"
    },
    "contracts/samples/SimpleAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport \"./SimpleAccount.sol\";\n\n/**\n * A sample factory contract for SimpleAccount\n * A UserOperations \"initCode\" holds the address of the factory, and a method call (to createAccount, in this sample factory).\n * The factory's createAccount returns the target account address even if it is already installed.\n * This way, the entryPoint.getSenderAddress() can be called either before or after the account is created.\n */\ncontract SimpleAccountFactory {\n    SimpleAccount public immutable accountImplementation;\n\n    constructor(IEntryPoint _entryPoint) {\n        accountImplementation = new SimpleAccount(_entryPoint);\n    }\n\n    /**\n     * create an account, and return its address.\n     * returns the address even if the account is already deployed.\n     * Note that during UserOperation execution, this method is called only if the account is not deployed.\n     * This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation\n     */\n    function createAccount(address owner,uint256 salt) public returns (SimpleAccount ret) {\n        address addr = getAddress(owner, salt);\n        uint codeSize = addr.code.length;\n        if (codeSize > 0) {\n            return SimpleAccount(payable(addr));\n        }\n        ret = SimpleAccount(payable(new ERC1967Proxy{salt : bytes32(salt)}(\n                address(accountImplementation),\n                abi.encodeCall(SimpleAccount.initialize, (owner))\n            )));\n    }\n\n    /**\n     * calculate the counterfactual address of this account as it would be returned by createAccount()\n     */\n    function getAddress(address owner,uint256 salt) public view returns (address) {\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\n                type(ERC1967Proxy).creationCode,\n                abi.encode(\n                    address(accountImplementation),\n                    abi.encodeCall(SimpleAccount.initialize, (owner))\n                )\n            )));\n    }\n}\n"
    },
    "contracts/samples/TokenPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n// Import the required libraries and contracts\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"../core/BasePaymaster.sol\";\nimport \"../core/UserOperationLib.sol\";\nimport \"./utils/UniswapHelper.sol\";\nimport \"./utils/OracleHelper.sol\";\n\n/// @title Sample ERC-20 Token Paymaster for ERC-4337\n/// This Paymaster covers gas fees in exchange for ERC20 tokens charged using allowance pre-issued by ERC-4337 accounts.\n/// The contract refunds excess tokens if the actual gas cost is lower than the initially provided amount.\n/// The token price cannot be queried in the validation code due to storage access restrictions of ERC-4337.\n/// The price is cached inside the contract and is updated in the 'postOp' stage if the change is >10%.\n/// It is theoretically possible the token has depreciated so much since the last 'postOp' the refund becomes negative.\n/// The contract reverts the inner user transaction in that case but keeps the charge.\n/// The contract also allows honest clients to prepay tokens at a higher price to avoid getting reverted.\n/// It also allows updating price configuration and withdrawing tokens by the contract owner.\n/// The contract uses an Oracle to fetch the latest token prices.\n/// @dev Inherits from BasePaymaster.\ncontract TokenPaymaster is BasePaymaster, UniswapHelper, OracleHelper {\n\n    struct TokenPaymasterConfig {\n        /// @notice The price markup percentage applied to the token price (1e6 = 100%)\n        uint256 priceMarkup;\n\n        /// @notice Exchange tokens to native currency if the EntryPoint balance of this Paymaster falls below this value\n        uint128 minEntryPointBalance;\n\n        /// @notice Estimated gas cost for refunding tokens after the transaction is completed\n        uint48 refundPostopCost;\n\n        /// @notice Transactions are only valid as long as the cached price is not older than this value\n        uint48 priceMaxAge;\n    }\n\n    event ConfigUpdated(TokenPaymasterConfig tokenPaymasterConfig);\n\n    event UserOperationSponsored(address indexed user, uint256 actualTokenCharge, uint256 actualGasCost, uint256 actualTokenPrice);\n\n    event Received(address indexed sender, uint256 value);\n\n    /// @notice All 'price' variables are multiplied by this value to avoid rounding up\n    uint256 private constant PRICE_DENOMINATOR = 1e26;\n\n    TokenPaymasterConfig private tokenPaymasterConfig;\n\n    /// @notice Initializes the TokenPaymaster contract with the given parameters.\n    /// @param _token The ERC20 token used for transaction fee payments.\n    /// @param _entryPoint The EntryPoint contract used in the Account Abstraction infrastructure.\n    /// @param _wrappedNative The ERC-20 token that wraps the native asset for current chain.\n    /// @param _uniswap The Uniswap V3 SwapRouter contract.\n    /// @param _tokenPaymasterConfig The configuration for the Token Paymaster.\n    /// @param _oracleHelperConfig The configuration for the Oracle Helper.\n    /// @param _uniswapHelperConfig The configuration for the Uniswap Helper.\n    /// @param _owner The address that will be set as the owner of the contract.\n    constructor(\n        IERC20Metadata _token,\n        IEntryPoint _entryPoint,\n        IERC20 _wrappedNative,\n        ISwapRouter _uniswap,\n        TokenPaymasterConfig memory _tokenPaymasterConfig,\n        OracleHelperConfig memory _oracleHelperConfig,\n        UniswapHelperConfig memory _uniswapHelperConfig,\n        address _owner\n    )\n    BasePaymaster(\n    _entryPoint\n    )\n    OracleHelper(\n    _oracleHelperConfig\n    )\n    UniswapHelper(\n    _token,\n    _wrappedNative,\n    _uniswap,\n    10 ** _token.decimals(),\n    _uniswapHelperConfig\n    )\n    {\n        setTokenPaymasterConfig(_tokenPaymasterConfig);\n        transferOwnership(_owner);\n    }\n\n    /// @notice Updates the configuration for the Token Paymaster.\n    /// @param _tokenPaymasterConfig The new configuration struct.\n    function setTokenPaymasterConfig(\n        TokenPaymasterConfig memory _tokenPaymasterConfig\n    ) public onlyOwner {\n        require(_tokenPaymasterConfig.priceMarkup <= 2 * PRICE_DENOMINATOR, \"TPM: price markup too high\");\n        require(_tokenPaymasterConfig.priceMarkup >= PRICE_DENOMINATOR, \"TPM: price markup too low\");\n        tokenPaymasterConfig = _tokenPaymasterConfig;\n        emit ConfigUpdated(_tokenPaymasterConfig);\n    }\n\n    function setUniswapConfiguration(\n        UniswapHelperConfig memory _uniswapHelperConfig\n    ) external onlyOwner {\n        _setUniswapHelperConfiguration(_uniswapHelperConfig);\n    }\n\n    /// @notice Allows the contract owner to withdraw a specified amount of tokens from the contract.\n    /// @param to The address to transfer the tokens to.\n    /// @param amount The amount of tokens to transfer.\n    function withdrawToken(address to, uint256 amount) external onlyOwner {\n        SafeERC20.safeTransfer(token, to, amount);\n    }\n\n    /// @notice Validates a paymaster user operation and calculates the required token amount for the transaction.\n    /// @param userOp The user operation data.\n    /// @param requiredPreFund The amount of tokens required for pre-funding.\n    /// @return context The context containing the token amount and user sender address (if applicable).\n    /// @return validationResult A uint256 value indicating the result of the validation (always 0 in this implementation).\n    function _validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32, uint256 requiredPreFund)\n    internal\n    override\n    returns (bytes memory context, uint256 validationResult) {unchecked {\n            uint256 priceMarkup = tokenPaymasterConfig.priceMarkup;\n            uint256 paymasterAndDataLength = userOp.paymasterAndData.length - PAYMASTER_DATA_OFFSET;\n            require(paymasterAndDataLength == 0 || paymasterAndDataLength == 32,\n                \"TPM: invalid data length\"\n            );\n            uint256 preChargeNative = requiredPreFund + (tokenPaymasterConfig.refundPostopCost * userOp.maxFeePerGas);\n        // note: as price is in ether-per-token and we want more tokens increasing it means dividing it by markup\n            uint256 cachedPriceWithMarkup = cachedPrice * PRICE_DENOMINATOR / priceMarkup;\n            if (paymasterAndDataLength == 32) {\n                uint256 clientSuppliedPrice = uint256(bytes32(userOp.paymasterAndData[PAYMASTER_DATA_OFFSET : PAYMASTER_DATA_OFFSET + 32]));\n                if (clientSuppliedPrice < cachedPriceWithMarkup) {\n                    // note: smaller number means 'more ether per token'\n                    cachedPriceWithMarkup = clientSuppliedPrice;\n                }\n            }\n            uint256 tokenAmount = weiToToken(preChargeNative, cachedPriceWithMarkup);\n            SafeERC20.safeTransferFrom(token, userOp.sender, address(this), tokenAmount);\n            context = abi.encode(tokenAmount, userOp.sender);\n            validationResult = _packValidationData(\n                false,\n                uint48(cachedPriceTimestamp + tokenPaymasterConfig.priceMaxAge),\n                0\n            );\n        }\n    }\n\n    /// @notice Performs post-operation tasks, such as updating the token price and refunding excess tokens.\n    /// @dev This function is called after a user operation has been executed or reverted.\n    /// @param context The context containing the token amount and user sender address.\n    /// @param actualGasCost The actual gas cost of the transaction.\n    /// @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n    //      and maxPriorityFee (and basefee)\n    //      It is not the same as tx.gasprice, which is what the bundler pays.\n    function _postOp(PostOpMode, bytes calldata context, uint256 actualGasCost, uint actualUserOpFeePerGas) internal override {\n        unchecked {\n            uint256 priceMarkup = tokenPaymasterConfig.priceMarkup;\n            (\n                uint256 preCharge,\n                address userOpSender\n            ) = abi.decode(context, (uint256, address));\n            uint256 _cachedPrice = updateCachedPrice(false);\n        // note: as price is in ether-per-token and we want more tokens increasing it means dividing it by markup\n            uint256 cachedPriceWithMarkup = _cachedPrice * PRICE_DENOMINATOR / priceMarkup;\n        // Refund tokens based on actual gas cost\n            uint256 actualChargeNative = actualGasCost + tokenPaymasterConfig.refundPostopCost * actualUserOpFeePerGas;\n            uint256 actualTokenNeeded = weiToToken(actualChargeNative, cachedPriceWithMarkup);\n            if (preCharge > actualTokenNeeded) {\n                // If the initially provided token amount is greater than the actual amount needed, refund the difference\n                SafeERC20.safeTransfer(\n                    token,\n                    userOpSender,\n                    preCharge - actualTokenNeeded\n                );\n            } else if (preCharge < actualTokenNeeded) {\n                // Attempt to cover Paymaster's gas expenses by withdrawing the 'overdraft' from the client\n                // If the transfer reverts also revert the 'postOp' to remove the incentive to cheat\n                SafeERC20.safeTransferFrom(\n                    token,\n                    userOpSender,\n                    address(this),\n                    actualTokenNeeded - preCharge\n                );\n            }\n\n            emit UserOperationSponsored(userOpSender, actualTokenNeeded, actualGasCost, _cachedPrice);\n            refillEntryPointDeposit(_cachedPrice);\n        }\n    }\n\n    /// @notice If necessary this function uses this Paymaster's token balance to refill the deposit on EntryPoint\n    /// @param _cachedPrice the token price that will be used to calculate the swap amount.\n    function refillEntryPointDeposit(uint256 _cachedPrice) private {\n        uint256 currentEntryPointBalance = entryPoint.balanceOf(address(this));\n        if (\n            currentEntryPointBalance < tokenPaymasterConfig.minEntryPointBalance\n        ) {\n            uint256 swappedWeth = _maybeSwapTokenToWeth(token, _cachedPrice);\n            unwrapWeth(swappedWeth);\n            entryPoint.depositTo{value: address(this).balance}(address(this));\n        }\n    }\n\n    function getGasPrice(uint256 maxFeePerGas, uint256 maxPriorityFeePerGas) internal view returns (uint256) {\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            // legacy mode (for networks that don't support the 'basefee' opcode)\n            return maxFeePerGas;\n        }\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n    }\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n}\n"
    },
    "contracts/samples/utils/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    function decimals() external view returns (uint8);\n    function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/samples/utils/OracleHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable not-rely-on-time */\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\n\nimport \"./IOracle.sol\";\n\n/// @title Helper functions for dealing with various forms of price feed oracles.\n/// @notice Maintains a price cache and updates the current price if needed.\n/// In the best case scenario we have a direct oracle from the token to the native asset.\n/// Also support tokens that have no direct price oracle to the native asset.\n/// Sometimes oracles provide the price in the opposite direction of what we need in the moment.\nabstract contract OracleHelper {\n\n    event TokenPriceUpdated(uint256 currentPrice, uint256 previousPrice, uint256 cachedPriceTimestamp);\n\n    uint256 private constant PRICE_DENOMINATOR = 1e26;\n\n    struct OracleHelperConfig {\n\n        /// @notice The price cache will be returned without even fetching the oracles for this number of seconds\n        uint48 cacheTimeToLive;\n\n        /// @notice The Oracle contract used to fetch the latest token prices\n        IOracle tokenOracle;\n\n        /// @notice The Oracle contract used to fetch the latest ETH prices\n        IOracle nativeOracle;\n\n        /// @notice If 'true' we will fetch price directly from tokenOracle\n        /// @notice If 'false' we will use nativeOracle to establish a token price through a shared third currency\n        bool tokenToNativeOracle;\n\n        /// @notice 'false' if price is dollars-per-token (or ether-per-token), 'true' if price is tokens-per-dollar\n        bool tokenOracleReverse;\n\n        /// @notice 'false' if price is dollars-per-ether, 'true' if price is ether-per-dollar\n        bool nativeOracleReverse;\n\n        /// @notice The price update threshold percentage that triggers a price update (1e6 = 100%)\n        uint48 priceUpdateThreshold;\n\n    }\n\n    /// @notice The cached token price from the Oracle, always in (ether-per-token) * PRICE_DENOMINATOR format\n    uint256 public cachedPrice;\n\n    /// @notice The timestamp of a block when the cached price was updated\n    uint48 public cachedPriceTimestamp;\n\n    OracleHelperConfig private oracleHelperConfig;\n\n    /// @notice The \"10^(tokenOracle.decimals)\" value used for the price calculation\n    uint128 private tokenOracleDecimalPower;\n\n    /// @notice The \"10^(nativeOracle.decimals)\" value used for the price calculation\n    uint128 private nativeOracleDecimalPower;\n\n    constructor (\n        OracleHelperConfig memory _oracleHelperConfig\n    ) {\n        cachedPrice = type(uint256).max; // initialize the storage slot to invalid value\n        _setOracleConfiguration(\n            _oracleHelperConfig\n        );\n    }\n\n    function _setOracleConfiguration(\n        OracleHelperConfig memory _oracleHelperConfig\n    ) private {\n        oracleHelperConfig = _oracleHelperConfig;\n        require(_oracleHelperConfig.priceUpdateThreshold <= 1e6, \"TPM: update threshold too high\");\n        tokenOracleDecimalPower = uint128(10 ** oracleHelperConfig.tokenOracle.decimals());\n        nativeOracleDecimalPower = uint128(10 ** oracleHelperConfig.nativeOracle.decimals());\n    }\n\n    /// @notice Updates the token price by fetching the latest price from the Oracle.\n    function updateCachedPrice(bool force) public returns (uint256 newPrice) {\n        uint256 cacheTimeToLive = oracleHelperConfig.cacheTimeToLive;\n        uint256 cacheAge = block.timestamp - cachedPriceTimestamp;\n        if (!force && cacheAge <= cacheTimeToLive) {\n            return cachedPrice;\n        }\n        uint256 priceUpdateThreshold = oracleHelperConfig.priceUpdateThreshold;\n        IOracle tokenOracle = oracleHelperConfig.tokenOracle;\n        IOracle nativeOracle = oracleHelperConfig.nativeOracle;\n\n        uint256 _cachedPrice = cachedPrice;\n        uint256 tokenPrice = fetchPrice(tokenOracle);\n        uint256 nativeAssetPrice = 1;\n        // If the 'TokenOracle' returns the price in the native asset units there is no need to fetch native asset price\n        if (!oracleHelperConfig.tokenToNativeOracle) {\n            nativeAssetPrice = fetchPrice(nativeOracle);\n        }\n        uint256 price = calculatePrice(\n            tokenPrice,\n            nativeAssetPrice,\n            oracleHelperConfig.tokenOracleReverse,\n            oracleHelperConfig.nativeOracleReverse\n        );\n        uint256 priceNewByOld = price * PRICE_DENOMINATOR / _cachedPrice;\n\n        bool updateRequired = force ||\n            priceNewByOld > PRICE_DENOMINATOR + priceUpdateThreshold ||\n            priceNewByOld < PRICE_DENOMINATOR - priceUpdateThreshold;\n        if (!updateRequired) {\n            return _cachedPrice;\n        }\n        uint256 previousPrice = _cachedPrice;\n        _cachedPrice = price;\n        cachedPrice = _cachedPrice;\n        cachedPriceTimestamp = uint48(block.timestamp);\n        emit TokenPriceUpdated(_cachedPrice, previousPrice, cachedPriceTimestamp);\n        return _cachedPrice;\n    }\n\n    /**\n     * Calculate the effective price of the selected token denominated in native asset.\n     *\n     * @param tokenPrice - the price of the token relative to a native asset or a bridging asset like the U.S. dollar.\n     * @param nativeAssetPrice - the price of the native asset relative to a bridging asset or 1 if no bridging needed.\n     * @param tokenOracleReverse - flag indicating direction of the \"tokenPrice\".\n     * @param nativeOracleReverse - flag indicating direction of the \"nativeAssetPrice\".\n     * @return the ether-per-token price multiplied by the PRICE_DENOMINATOR constant.\n     */\n    function calculatePrice(\n        uint256 tokenPrice,\n        uint256 nativeAssetPrice,\n        bool tokenOracleReverse,\n        bool nativeOracleReverse\n    ) private view returns (uint256){\n        // tokenPrice is normalized as dollars-per-token\n        if (tokenOracleReverse) {\n            // inverting tokenPrice that was tokens-per-dollar (or tokens-per-ether)\n            tokenPrice = PRICE_DENOMINATOR * tokenOracleDecimalPower / tokenPrice;\n        } else {\n            // tokenPrice already dollars-per-token (or ethers-per-token)\n            tokenPrice = PRICE_DENOMINATOR * tokenPrice / tokenOracleDecimalPower;\n        }\n\n        if (nativeOracleReverse) {\n            // multiplying by nativeAssetPrice that is  ethers-per-dollar\n            // => result = (dollar / token) * (ether / dollar) = ether / token\n            return nativeAssetPrice * tokenPrice / nativeOracleDecimalPower;\n        } else {\n            // dividing by nativeAssetPrice that is dollars-per-ether\n            // => result = (dollar / token) / (dollar / ether) = ether / token\n            return tokenPrice * nativeOracleDecimalPower / nativeAssetPrice;\n        }\n    }\n\n    /// @notice Fetches the latest price from the given Oracle.\n    /// @dev This function is used to get the latest price from the tokenOracle or nativeOracle.\n    /// @param _oracle The Oracle contract to fetch the price from.\n    /// @return price The latest price fetched from the Oracle.\n    function fetchPrice(IOracle _oracle) internal view returns (uint256 price) {\n        (uint80 roundId, int256 answer,, uint256 updatedAt, uint80 answeredInRound) = _oracle.latestRoundData();\n        require(answer > 0, \"TPM: Chainlink price <= 0\");\n        // 2 days old price is considered stale since the price is updated every 24 hours\n        require(updatedAt >= block.timestamp - 60 * 60 * 24 * 2, \"TPM: Incomplete round\");\n        require(answeredInRound >= roundId, \"TPM: Stale price\");\n        price = uint256(answer);\n    }\n}\n"
    },
    "contracts/samples/utils/UniswapHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable not-rely-on-time */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryPayments.sol\";\n\nabstract contract UniswapHelper {\n    event UniswapReverted(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOutMin);\n\n    uint256 private constant PRICE_DENOMINATOR = 1e26;\n\n    struct UniswapHelperConfig {\n        /// @notice Minimum native asset amount to receive from a single swap\n        uint256 minSwapAmount;\n\n        uint24 uniswapPoolFee;\n\n        uint8 slippage;\n    }\n\n    /// @notice The Uniswap V3 SwapRouter contract\n    ISwapRouter public immutable uniswap;\n\n    /// @notice The ERC20 token used for transaction fee payments\n    IERC20 public immutable token;\n\n    /// @notice The ERC-20 token that wraps the native asset for current chain\n    IERC20 public immutable wrappedNative;\n\n    UniswapHelperConfig private uniswapHelperConfig;\n\n    /// @notice The \"10^(token.decimals)\" value used for the price calculation\n    uint256 private immutable tokenDecimalPower;\n\n    constructor(\n        IERC20 _token,\n        IERC20 _wrappedNative,\n        ISwapRouter _uniswap,\n        uint256 _tokenDecimalPower,\n        UniswapHelperConfig memory _uniswapHelperConfig\n    ){\n        _token.approve(address(_uniswap), type(uint256).max);\n        token = _token;\n        wrappedNative = _wrappedNative;\n        uniswap = _uniswap;\n        tokenDecimalPower = _tokenDecimalPower;\n        _setUniswapHelperConfiguration(_uniswapHelperConfig);\n    }\n\n    function _setUniswapHelperConfiguration(UniswapHelperConfig memory _uniswapHelperConfig) internal {\n        uniswapHelperConfig = _uniswapHelperConfig;\n    }\n\n    function _maybeSwapTokenToWeth(IERC20 tokenIn, uint256 quote) internal returns (uint256) {\n        uint256 tokenBalance = tokenIn.balanceOf(address(this));\n        uint256 amountOutMin = addSlippage(tokenToWei(tokenBalance, quote), uniswapHelperConfig.slippage);\n        if (amountOutMin < uniswapHelperConfig.minSwapAmount) {\n            return 0;\n        }\n        // note: calling 'swapToToken' but destination token is Wrapped Ether\n        return swapToToken(\n            address(tokenIn),\n            address(wrappedNative),\n            tokenBalance,\n            amountOutMin,\n            uniswapHelperConfig.uniswapPoolFee\n        );\n    }\n\n    function addSlippage(uint256 amount, uint8 slippage) private pure returns (uint256) {\n        return amount * (1000 - slippage) / 1000;\n    }\n\n\n    function tokenToWei(uint256 amount, uint256 price) public pure returns (uint256) {\n        return amount * price / PRICE_DENOMINATOR;\n    }\n\n    function weiToToken(uint256 amount, uint256 price) public pure returns (uint256) {\n        return amount * PRICE_DENOMINATOR / price;\n    }\n\n    // turn ERC-20 tokens into wrapped ETH at market price\n    function swapToWeth(\n        address tokenIn,\n        address wethOut,\n        uint256 amountOut,\n        uint24 fee\n    ) internal returns (uint256 amountIn) {\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams(\n            tokenIn,\n            wethOut, //tokenOut\n            fee,\n            address(uniswap), //recipient - keep WETH at SwapRouter for withdrawal\n            block.timestamp, //deadline\n            amountOut,\n            type(uint256).max,\n            0\n        );\n        amountIn = uniswap.exactOutputSingle(params);\n    }\n\n    function unwrapWeth(uint256 amount) internal {\n        IPeripheryPayments(address(uniswap)).unwrapWETH9(amount, address(this));\n    }\n\n    // swap ERC-20 tokens at market price\n    function swapToToken(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint24 fee\n    ) internal returns (uint256 amountOut) {\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams(\n            tokenIn, //tokenIn\n            tokenOut, //tokenOut\n            fee,\n            address(uniswap),\n            block.timestamp, //deadline\n            amountIn,\n            amountOutMin,\n            0\n        );\n        try uniswap.exactInputSingle(params) returns (uint256 _amountOut) {\n            amountOut = _amountOut;\n        } catch {\n            emit UniswapReverted(tokenIn, tokenOut, amountIn, amountOutMin);\n            amountOut = 0;\n        }\n    }\n}\n"
    },
    "contracts/samples/VerifyingPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n/* solhint-disable no-inline-assembly */\n\nimport \"../core/BasePaymaster.sol\";\nimport \"../core/UserOperationLib.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\n/**\n * A sample paymaster that uses external service to decide whether to pay for the UserOp.\n * The paymaster trusts an external signer to sign the transaction.\n * The calling user must pass the UserOp to that external signer first, which performs\n * whatever off-chain verification before signing the UserOp.\n * Note that this signature is NOT a replacement for the account-specific signature:\n * - the paymaster checks a signature to agree to PAY for GAS.\n * - the account checks a signature to prove identity and account ownership.\n */\ncontract VerifyingPaymaster is BasePaymaster {\n\n    using UserOperationLib for PackedUserOperation;\n\n    address public immutable verifyingSigner;\n\n    uint256 private constant VALID_TIMESTAMP_OFFSET = PAYMASTER_DATA_OFFSET;\n\n    uint256 private constant SIGNATURE_OFFSET = VALID_TIMESTAMP_OFFSET + 64;\n\n    constructor(IEntryPoint _entryPoint, address _verifyingSigner) BasePaymaster(_entryPoint) {\n        verifyingSigner = _verifyingSigner;\n    }\n\n    /**\n     * return the hash we're going to sign off-chain (and validate on-chain)\n     * this method is called by the off-chain service, to sign the request.\n     * it is called on-chain from the validatePaymasterUserOp, to validate the signature.\n     * note that this signature covers all fields of the UserOperation, except the \"paymasterAndData\",\n     * which will carry the signature itself.\n     */\n    function getHash(PackedUserOperation calldata userOp, uint48 validUntil, uint48 validAfter)\n    public view returns (bytes32) {\n        //can't use userOp.hash(), since it contains also the paymasterAndData itself.\n        address sender = userOp.getSender();\n        return\n            keccak256(\n            abi.encode(\n                sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.accountGasLimits,\n                uint256(bytes32(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_DATA_OFFSET])),\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas,\n                block.chainid,\n                address(this),\n                validUntil,\n                validAfter\n            )\n        );\n    }\n\n    /**\n     * verify our external signer signed this request.\n     * the \"paymasterAndData\" is expected to be the paymaster and a signature over the entire request params\n     * paymasterAndData[:20] : address(this)\n     * paymasterAndData[20:84] : abi.encode(validUntil, validAfter)\n     * paymasterAndData[84:] : signature\n     */\n    function _validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n    internal view override returns (bytes memory context, uint256 validationData) {\n        (requiredPreFund);\n\n        (uint48 validUntil, uint48 validAfter, bytes calldata signature) = parsePaymasterAndData(userOp.paymasterAndData);\n        //ECDSA library supports both 64 and 65-byte long signatures.\n        // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n        require(signature.length == 64 || signature.length == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n        bytes32 hash = MessageHashUtils.toEthSignedMessageHash(getHash(userOp, validUntil, validAfter));\n\n        //don't revert on signature failure: return SIG_VALIDATION_FAILED\n        if (verifyingSigner != ECDSA.recover(hash, signature)) {\n            return (\"\", _packValidationData(true, validUntil, validAfter));\n        }\n\n        //no need for other on-chain validation: entire UserOp should have been checked\n        // by the external service prior to signing it.\n        return (\"\", _packValidationData(false, validUntil, validAfter));\n    }\n\n    function parsePaymasterAndData(bytes calldata paymasterAndData) public pure returns (uint48 validUntil, uint48 validAfter, bytes calldata signature) {\n        (validUntil, validAfter) = abi.decode(paymasterAndData[VALID_TIMESTAMP_OFFSET :], (uint48, uint48));\n        signature = paymasterAndData[SIGNATURE_OFFSET :];\n    }\n}\n"
    },
    "contracts/test/BrokenBlsAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/* solhint-disable one-contract-per-file */\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport \"../samples/SimpleAccount.sol\";\nimport \"../samples/bls/IBLSAccount.sol\";\n\n/**\n * for testing: a BLS account that fails to return its public-key (completely ignores its publickey)\n * this is a copy of the normal bls account, but it returns a public-key unrelated to the one it is constructed with.\n */\ncontract BrokenBLSAccount is SimpleAccount, IBLSAccount {\n    address public immutable aggregator;\n\n    // The constructor is used only for the \"implementation\" and only sets immutable values.\n    // Mutable values slots for proxy accounts are set by the 'initialize' function.\n    constructor(IEntryPoint anEntryPoint, address anAggregator) SimpleAccount(anEntryPoint)  {\n        aggregator = anAggregator;\n    }\n\n    function initialize(uint256[4] memory aPublicKey) public virtual initializer {\n        (aPublicKey);\n        super._initialize(address(0));\n    }\n\n    function _validateSignature(PackedUserOperation calldata userOp, bytes32 userOpHash)\n    internal override view returns (uint256 validationData) {\n\n        (userOp, userOpHash);\n        return _packValidationData(ValidationData(aggregator, 0,0));\n    }\n\n    function getBlsPublicKey() external override pure returns (uint256[4] memory) {\n        uint256[4] memory pubkey;\n        return pubkey;\n    }\n}\n\n\n/**\n * Based n SimpleAccountFactory\n * can't be a subclass, since both constructor and createAccount depend on the\n * actual wallet contract constructor and initializer\n */\ncontract BrokenBLSAccountFactory {\n    BrokenBLSAccount public immutable accountImplementation;\n\n    constructor(IEntryPoint entryPoint, address aggregator){\n        accountImplementation = new BrokenBLSAccount(entryPoint, aggregator);\n    }\n\n    /**\n     * create an account, and return its address.\n     * returns the address even if the account is already deployed.\n     * Note that during UserOperation execution, this method is called only if the account is not deployed.\n     * This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation\n     * Also note that out BLSSignatureAggregator requires that the public-key is the last parameter\n     */\n    function createAccount(uint salt, uint256[4] memory aPublicKey) public returns (BrokenBLSAccount) {\n\n        address addr = getAddress(salt, aPublicKey);\n        uint codeSize = addr.code.length;\n        if (codeSize > 0) {\n            return BrokenBLSAccount(payable(addr));\n        }\n        return BrokenBLSAccount(payable(new ERC1967Proxy{salt : bytes32(salt)}(\n                address(accountImplementation),\n                abi.encodeCall(BrokenBLSAccount.initialize, aPublicKey)\n            )));\n    }\n\n    /**\n     * calculate the counterfactual address of this account as it would be returned by createAccount()\n     */\n    function getAddress(uint salt, uint256[4] memory aPublicKey) public view returns (address) {\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\n                type(ERC1967Proxy).creationCode,\n                abi.encode(\n                    address(accountImplementation),\n                    abi.encodeCall(BrokenBLSAccount.initialize, (aPublicKey))\n                )\n            )));\n    }\n}\n"
    },
    "contracts/test/MaliciousAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"../core/UserOperationLib.sol\";\n\ncontract MaliciousAccount is IAccount {\n    IEntryPoint private ep;\n    constructor(IEntryPoint _ep) payable {\n        ep = _ep;\n    }\n    function validateUserOp(PackedUserOperation calldata userOp, bytes32, uint256 missingAccountFunds)\n    external returns (uint256 validationData) {\n        ep.depositTo{value : missingAccountFunds}(address(this));\n        // Now calculate basefee per EntryPoint.getUserOpGasPrice() and compare it to the basefe we pass off-chain in the signature\n        uint256 externalBaseFee = abi.decode(userOp.signature, (uint256));\n        (uint256 verificationGasLimit, uint256 callGasLimit) = UserOperationLib.unpackAccountGasLimits(userOp.accountGasLimits);\n        uint256 requiredGas = verificationGasLimit +\n                            callGasLimit +\n                            userOp.preVerificationGas;\n        uint256 gasPrice = missingAccountFunds / requiredGas;\n        uint256 basefee = gasPrice - userOp.maxPriorityFeePerGas;\n        require (basefee == externalBaseFee, \"Revert after first validation\");\n        return 0;\n    }\n}\n"
    },
    "contracts/test/TestAggregatedAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../samples/SimpleAccount.sol\";\n\n/**\n * test aggregated-signature account.\n * works only with TestAggregatedSignature, which doesn't really check signature, but nonce sum\n * a true aggregated account should expose data (e.g. its public key) to the aggregator.\n */\ncontract TestAggregatedAccount is SimpleAccount {\n    address public immutable aggregator;\n\n    // The constructor is used only for the \"implementation\" and only sets immutable values.\n    // Mutable value slots for proxy accounts are set by the 'initialize' function.\n    constructor(IEntryPoint anEntryPoint, address anAggregator) SimpleAccount(anEntryPoint) {\n        aggregator = anAggregator;\n    }\n\n    /// @inheritdoc SimpleAccount\n    function initialize(address) public virtual override initializer {\n        super._initialize(address(0));\n    }\n\n    function _validateSignature(PackedUserOperation calldata userOp, bytes32 userOpHash)\n    internal override view returns (uint256 validationData) {\n        (userOp, userOpHash);\n        return _packValidationData(ValidationData(aggregator, 0, 0));\n    }\n}\n"
    },
    "contracts/test/TestAggregatedAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport \"./TestAggregatedAccount.sol\";\n\n/**\n * Based on SimpleAccountFactory.\n * Cannot be a subclass since both constructor and createAccount depend on the\n * constructor and initializer of the actual account contract.\n */\ncontract TestAggregatedAccountFactory {\n    TestAggregatedAccount public immutable accountImplementation;\n\n    constructor(IEntryPoint anEntryPoint, address anAggregator){\n        accountImplementation = new TestAggregatedAccount(anEntryPoint, anAggregator);\n    }\n\n    /**\n     * create an account, and return its address.\n     * returns the address even if the account is already deployed.\n     * Note that during UserOperation execution, this method is called only if the account is not deployed.\n     * This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation\n     */\n    function createAccount(address owner,uint256 salt) public returns (TestAggregatedAccount ret) {\n        address addr = getAddress(owner, salt);\n        uint codeSize = addr.code.length;\n        if (codeSize > 0) {\n            return TestAggregatedAccount(payable(addr));\n        }\n        ret = TestAggregatedAccount(payable(new ERC1967Proxy{salt : bytes32(salt)}(\n                address(accountImplementation),\n                abi.encodeCall(TestAggregatedAccount.initialize, (owner))\n            )));\n    }\n\n    /**\n     * calculate the counterfactual address of this account as it would be returned by createAccount()\n     */\n    function getAddress(address owner,uint256 salt) public view returns (address) {\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\n                type(ERC1967Proxy).creationCode,\n                abi.encode(\n                    address(accountImplementation),\n                    abi.encodeCall(TestAggregatedAccount.initialize, (owner))\n                )\n            )));\n    }\n}\n"
    },
    "contracts/test/TestCounter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n//sample \"receiver\" contract, for testing \"exec\" from account.\ncontract TestCounter {\n    mapping(address => uint256) public counters;\n\n    function count() public {\n        counters[msg.sender] = counters[msg.sender] + 1;\n    }\n\n    function getCount(address user) public view returns (uint256) {\n        return counters[user];\n    }\n\n    function countFail() public pure {\n        revert(\"count failed\");\n    }\n\n    function justemit() public {\n        emit CalledFrom(msg.sender);\n    }\n\n    event CalledFrom(address sender);\n\n    //helper method to waste gas\n    // repeat - waste gas on writing storage in a loop\n    // junk - dynamic buffer to stress the function size.\n    mapping(uint256 => uint256) public xxx;\n    uint256 public offset;\n\n    function gasWaster(uint256 repeat, string calldata /*junk*/) external {\n        for (uint256 i = 1; i <= repeat; i++) {\n            offset++;\n            xxx[offset] = i;\n        }\n    }\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestERC20 is ERC20 {\n    uint8 private immutable __decimals;\n\n    constructor(uint8 _decimals) ERC20(\"TestERC20\", \"T20\") {\n        _mint(msg.sender, 1000000000000000000000000);\n        __decimals = _decimals;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return __decimals;\n    }\n\n    function sudoMint(address _to, uint256 _amount) external {\n        _mint(_to, _amount);\n    }\n\n    function sudoTransfer(address _from, address _to) external {\n        _transfer(_from, _to, balanceOf(_from));\n    }\n\n    function sudoApprove(address _from, address _to, uint256 _amount) external {\n        _approve(_from, _to, _amount);\n    }\n}\n"
    },
    "contracts/test/TestExecAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/* solhint-disable one-contract-per-file */\n/* solhint-disable avoid-low-level-calls */\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport \"../samples/SimpleAccount.sol\";\nimport \"../interfaces/IAccountExecute.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * a sample account with execUserOp.\n * Note that this account does nothing special with the userop, just extract\n * call to execute. In theory, such account can reference the signature, the hash, etc.\n */\ncontract TestExecAccount is SimpleAccount, IAccountExecute {\n\n    constructor(IEntryPoint anEntryPoint) SimpleAccount(anEntryPoint){\n    }\n\n    event Executed(PackedUserOperation userOp, bytes innerCallRet);\n\n    function executeUserOp(PackedUserOperation calldata userOp, bytes32 /*userOpHash*/) external {\n        _requireFromEntryPointOrOwner();\n\n        // read from the userOp.callData, but skip the \"magic\" prefix (executeUserOp sig),\n        // which caused it to call this method.\n        bytes calldata innerCall = userOp.callData[4 :];\n\n        bytes memory innerCallRet;\n        if (innerCall.length > 0) {\n            (address target, bytes memory data) = abi.decode(innerCall, (address, bytes));\n            bool success;\n            (success, innerCallRet) = target.call(data);\n            require(success, \"inner call failed\");\n        }\n\n        emit Executed(userOp, innerCallRet);\n    }\n}\n\ncontract TestExecAccountFactory {\n    TestExecAccount public immutable accountImplementation;\n\n    constructor(IEntryPoint _entryPoint) {\n        accountImplementation = new TestExecAccount(_entryPoint);\n    }\n\n    function createAccount(address owner, uint256 salt) public returns (address ret) {\n        address addr = getAddress(owner, salt);\n        uint codeSize = addr.code.length;\n        if (codeSize > 0) {\n            return addr;\n        }\n        ret = address(new ERC1967Proxy{salt: bytes32(salt)}(\n            address(accountImplementation),\n            abi.encodeCall(SimpleAccount.initialize, (owner))\n        ));\n    }\n\n    /**\n     * calculate the counterfactual address of this account as it would be returned by createAccount()\n     */\n    function getAddress(address owner, uint256 salt) public view returns (address) {\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\n            type(ERC1967Proxy).creationCode,\n            abi.encode(\n                address(accountImplementation),\n                abi.encodeCall(SimpleAccount.initialize, (owner))\n            )\n        )));\n    }\n}\n"
    },
    "contracts/test/TestExpirePaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport \"../core/BasePaymaster.sol\";\nimport \"../core/UserOperationLib.sol\";\n\n/**\n * test expiry mechanism: paymasterData encodes the \"validUntil\" and validAfter\" times\n */\ncontract TestExpirePaymaster is BasePaymaster {\n    // solhint-disable no-empty-blocks\n    constructor(IEntryPoint _entryPoint) BasePaymaster(_entryPoint)\n    {}\n\n    function _validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    internal virtual override view\n    returns (bytes memory context, uint256 validationData) {\n        (userOp, userOpHash, maxCost);\n        (uint48 validAfter, uint48 validUntil) = abi.decode(userOp.paymasterAndData[PAYMASTER_DATA_OFFSET :], (uint48, uint48));\n        validationData = _packValidationData(false, validUntil, validAfter);\n        context = \"\";\n    }\n}\n"
    },
    "contracts/test/TestExpiryAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport \"../samples/SimpleAccount.sol\";\n\n/**\n * A test account, for testing expiry.\n * add \"temporary\" owners, each with a time range (since..till) times for each.\n * NOTE: this is not a full \"session key\" implementation: a real session key should probably limit\n * other things, like target contracts and methods to be called.\n * also, the \"since\" value is not really useful, only for testing the entrypoint.\n */\ncontract TestExpiryAccount is SimpleAccount {\n\n    mapping(address => uint48) public ownerAfter;\n    mapping(address => uint48) public ownerUntil;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(IEntryPoint anEntryPoint) SimpleAccount(anEntryPoint) {}\n\n    function initialize(address anOwner) public virtual override initializer {\n        super._initialize(anOwner);\n        addTemporaryOwner(anOwner, 0, type(uint48).max);\n    }\n\n    // As this is a test contract, no need for proxy, so no need to disable init\n    // solhint-disable-next-line no-empty-blocks\n    function _disableInitializers() internal override {}\n\n    function addTemporaryOwner(address owner, uint48 _after, uint48 _until) public onlyOwner {\n        require(_until > _after, \"wrong until/after\");\n        ownerAfter[owner] = _after;\n        ownerUntil[owner] = _until;\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(PackedUserOperation calldata userOp, bytes32 userOpHash)\n    internal override view returns (uint256 validationData) {\n        bytes32 hash = MessageHashUtils.toEthSignedMessageHash(userOpHash);\n        address signer = ECDSA.recover(hash,userOp.signature);\n        uint48 _until = ownerUntil[signer];\n        uint48 _after = ownerAfter[signer];\n\n        //we have \"until\" value for all valid owners. so zero means \"invalid signature\"\n        bool sigFailed = _until == 0;\n        return _packValidationData(sigFailed, _until, _after);\n    }\n}\n"
    },
    "contracts/test/TestHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../core/Helpers.sol\";\n\ncontract TestHelpers {\n\n    function parseValidationData(uint validationData) public pure returns (ValidationData memory) {\n        return _parseValidationData(validationData);\n    }\n\n    function intersectTimeRange(uint256 validationData, uint256 paymasterValidationData) public pure returns (ValidationData memory) {\n        return _intersectTimeRange(validationData, paymasterValidationData);\n    }\n\n    function packValidationDataStruct(ValidationData memory data) public pure returns (uint256) {\n        return _packValidationData(data);\n    }\n\n    function packValidationData(bool sigFailed, uint48 validUntil, uint48 validAfter) public pure returns (uint256) {\n        return _packValidationData(sigFailed, validUntil, validAfter);\n    }\n}\n"
    },
    "contracts/test/TestOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../samples/IOracle.sol\";\n\ncontract TestOracle is IOracle {\n    function getTokenValueOfEth(uint256 ethOutput) external pure override returns (uint256 tokenInput) {\n        return ethOutput * 2;\n    }\n}\n"
    },
    "contracts/test/TestOracle2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"../samples/utils/IOracle.sol\";\n\ncontract TestOracle2 is IOracle {\n    int256 public price;\n    uint8 private _decimals_;\n\n    constructor(int256 _price, uint8 _decimals) {\n        price = _price;\n        _decimals_ = _decimals;\n    }\n\n    function setPrice(int256 _price) external {\n        price = _price;\n    }\n\n    function setDecimals(uint8 _decimals) external {\n        _decimals_ = _decimals;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals_;\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        // solhint-disable-next-line not-rely-on-time\n        return (73786976294838215802, price, 1680509051, block.timestamp, 73786976294838215802);\n    }\n}\n"
    },
    "contracts/test/TestPaymasterAcceptAll.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport \"../core/BasePaymaster.sol\";\n\n/**\n * test paymaster, that pays for everything, without any check.\n */\ncontract TestPaymasterAcceptAll is BasePaymaster {\n\n    constructor(IEntryPoint _entryPoint) BasePaymaster(_entryPoint) {\n        // to support \"deterministic address\" factory\n        // solhint-disable avoid-tx-origin\n        if (tx.origin != msg.sender) {\n            _transferOwnership(tx.origin);\n        }\n\n    }\n\n    function _validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    internal virtual override view\n    returns (bytes memory context, uint256 validationData) {\n        (userOp, userOpHash, maxCost);\n        return (\"\", 0);\n    }\n}\n"
    },
    "contracts/test/TestPaymasterRevertCustomError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport \"../core/BasePaymaster.sol\";\n\n/**\n * test postOp revert with custom error\n */\nerror CustomError(string customReason);\n\ncontract TestPaymasterRevertCustomError is BasePaymaster {\n    bytes32 private constant INNER_OUT_OF_GAS = hex\"deaddead\";\n\n    enum RevertType {\n        customError,\n        entryPointError\n    }\n\n    RevertType private revertType;\n\n    // solhint-disable no-empty-blocks\n    constructor(IEntryPoint _entryPoint) BasePaymaster(_entryPoint)\n    {}\n\n    function _validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32, uint256)\n    internal virtual override view\n    returns (bytes memory context, uint256 validationData) {\n        validationData = 0;\n        context = abi.encodePacked(userOp.sender);\n    }\n\n    function setRevertType(RevertType _revertType) external {\n        revertType = _revertType;\n    }\n\n    function _postOp(PostOpMode, bytes calldata, uint256, uint256) internal view override {\n        if (revertType == RevertType.customError){\n            revert CustomError(\"this is a long revert reason string we are looking for\");\n        }\n        else if (revertType == RevertType.entryPointError){\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                mstore(0, INNER_OUT_OF_GAS)\n                revert(0, 32)\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/TestPaymasterWithPostOp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport \"./TestPaymasterAcceptAll.sol\";\n/* solhint-disable no-empty-blocks */\n\n/**\n * test paymaster, that pays for everything, without any check.\n * explicitly returns a context, to test cost (for entrypoint) to call postOp\n */\ncontract TestPaymasterWithPostOp is TestPaymasterAcceptAll {\n\n    constructor(IEntryPoint _entryPoint) TestPaymasterAcceptAll(_entryPoint) {\n    }\n\n    function _validatePaymasterUserOp(PackedUserOperation calldata, bytes32, uint256)\n    internal virtual override view\n    returns (bytes memory context, uint256 validationData) {\n        // return a context, to force a call for postOp.\n        return (\"1\", 0);\n    }\n\n    function _postOp(PostOpMode, bytes calldata, uint256, uint256)\n    internal override {\n    }\n}\n"
    },
    "contracts/test/TestRevertAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n/* solhint-disable no-inline-assembly */\n\nimport \"../samples/SimpleAccount.sol\";\ncontract TestRevertAccount is IAccount {\n    IEntryPoint private ep;\n    constructor(IEntryPoint _ep) payable {\n        ep = _ep;\n    }\n\n    function validateUserOp(PackedUserOperation calldata, bytes32, uint256 missingAccountFunds)\n    external override returns (uint256 validationData) {\n        ep.depositTo{value : missingAccountFunds}(address(this));\n        return 0;\n    }\n\n    function revertLong(uint256 length) public pure{\n        assembly {\n            let size := 10\n\n            // set the \"revertLong\" string to the memory\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, add(size, 0x20)))\n            mstore(ptr, size)\n            mstore(add(ptr, 0x20), \"jay revert\")\n            revert(ptr, length)\n        }\n    }\n}\n"
    },
    "contracts/test/TestSignatureAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport \"../interfaces/IAggregator.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"../samples/SimpleAccount.sol\";\n\n/**\n * test signature aggregator.\n * the aggregated signature is the SUM of the nonce fields..\n */\ncontract TestSignatureAggregator is IAggregator {\n\n    /// @inheritdoc IAggregator\n    function validateSignatures(PackedUserOperation[] calldata userOps, bytes calldata signature) external pure override {\n        uint sum = 0;\n        for (uint i = 0; i < userOps.length; i++) {\n            uint nonce = userOps[i].nonce;\n            sum += nonce;\n        }\n        require(signature.length == 32, \"TestSignatureValidator: sig must be uint\");\n        (uint sig) = abi.decode(signature, (uint));\n        require(sig == sum, \"TestSignatureValidator: aggregated signature mismatch (nonce sum)\");\n    }\n\n    /// @inheritdoc IAggregator\n    function validateUserOpSignature(PackedUserOperation calldata)\n    external pure returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * dummy test aggregator: sum all nonce values of UserOps.\n     */\n    function aggregateSignatures(PackedUserOperation[] calldata userOps) external pure returns (bytes memory aggregatedSignature) {\n        uint sum = 0;\n        for (uint i = 0; i < userOps.length; i++) {\n            sum += userOps[i].nonce;\n        }\n        return abi.encode(sum);\n    }\n\n    /**\n     * Calls the 'addStake' method of the EntryPoint. Forwards the entire msg.value to this call.\n     * @param entryPoint - the EntryPoint to send the stake to.\n     * @param delay - the new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(IEntryPoint entryPoint, uint32 delay) external payable {\n        entryPoint.addStake{value: msg.value}(delay);\n    }\n}\n"
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    constructor ()\n        // solhint-disable-next-line no-empty-blocks\n        ERC20(\"TST\", \"TestToken\") {\n    }\n\n    function mint(address sender, uint256 amount) external {\n        _mint(sender, amount);\n    }\n}\n"
    },
    "contracts/test/TestUniswap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\n\nimport \"./TestWrappedNativeToken.sol\";\n\n/// @notice Very basic simulation of what Uniswap does with the swaps for the unit tests on the TokenPaymaster\n/// @dev Do not use to test any actual Uniswap interaction logic as this is way too simplistic\ncontract TestUniswap {\n    TestWrappedNativeToken public weth;\n\n    constructor(TestWrappedNativeToken _weth){\n        weth = _weth;\n    }\n\n    event StubUniswapExchangeEvent(uint256 amountIn, uint256 amountOut, address tokenIn, address tokenOut);\n\n    function exactOutputSingle(ISwapRouter.ExactOutputSingleParams calldata params) external returns (uint256) {\n        uint256 amountIn = params.amountInMaximum - 5;\n        emit StubUniswapExchangeEvent(\n            amountIn,\n            params.amountOut,\n            params.tokenIn,\n            params.tokenOut\n        );\n        IERC20(params.tokenIn).transferFrom(msg.sender, address(this), amountIn);\n        IERC20(params.tokenOut).transfer(params.recipient, params.amountOut);\n        return amountIn;\n    }\n\n    function exactInputSingle(ISwapRouter.ExactInputSingleParams calldata params) external returns (uint256) {\n        uint256 amountOut = params.amountOutMinimum + 5;\n        emit StubUniswapExchangeEvent(\n            params.amountIn,\n            amountOut,\n            params.tokenIn,\n            params.tokenOut\n        );\n        IERC20(params.tokenIn).transferFrom(msg.sender, address(this), params.amountIn);\n        IERC20(params.tokenOut).transfer(params.recipient, amountOut);\n        return amountOut;\n    }\n\n    /// @notice Simplified code copied from here:\n    /// https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol#L19\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceWETH9 = weth.balanceOf(address(this));\n        require(balanceWETH9 >= amountMinimum, \"Insufficient WETH9\");\n\n        if (balanceWETH9 > 0) {\n            weth.withdraw(balanceWETH9);\n            payable(recipient).transfer(balanceWETH9);\n        }\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "contracts/test/TestUtil.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport \"../core/UserOperationLib.sol\";\n\ncontract TestUtil {\n    using UserOperationLib for PackedUserOperation;\n\n    function encodeUserOp(PackedUserOperation calldata op) external pure returns (bytes memory){\n        return op.encode();\n    }\n\n}\n"
    },
    "contracts/test/TestWarmColdAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"../interfaces/IAccount.sol\";\n\n// Using eip-2929 (https://eips.ethereum.org/EIPS/eip-2929) warm/cold storage access gas costs to detect simulation vs execution\n// COLD_ACCOUNT_ACCESS_COST == 2600, COLD_SLOAD_COST == 2100, WARM_STORAGE_READ_COST == 100\ncontract TestWarmColdAccount is IAccount {\n    IEntryPoint private ep;\n    uint public state = 1;\n    constructor(IEntryPoint _ep) payable {\n        ep = _ep;\n    }\n\n    function validateUserOp(PackedUserOperation calldata userOp, bytes32, uint256 missingAccountFunds)\n    external override returns (uint256 validationData) {\n        ep.depositTo{value : missingAccountFunds}(address(this));\n        if (userOp.nonce == 1) {\n            // can only succeed if storage is already warm\n            this.touchStorage{gas: 1000}();\n        } else if (userOp.nonce == 2) {\n            address paymaster = address(bytes20(userOp.paymasterAndData[: 20]));\n            // can only succeed if storage is already warm\n            this.touchPaymaster{gas: 1000}(paymaster);\n        }\n        return 0;\n    }\n\n    function touchStorage() public view returns (uint256) {\n        return state;\n    }\n\n    function touchPaymaster(address paymaster) public view returns (uint256) {\n        return paymaster.code.length;\n    }\n}\n"
    },
    "contracts/test/TestWrappedNativeToken.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @notice The minimal \"Wrapped Ether\" ERC-20 token implementation.\n */\ncontract TestWrappedNativeToken is ERC20 {\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() ERC20(\"Wrapped Native Token\", \"wnTok\") {\n    }\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint amount) public {\n        _burn(msg.sender, amount);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success,) = msg.sender.call{value:amount}(\"\");\n        require(success, \"transfer failed\");\n    }\n}\n"
    },
    "contracts/utils/Exec.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.5 <0.9.0;\n\n// solhint-disable no-inline-assembly\n\n/**\n * Utility functions helpful when making different kinds of contract calls in Solidity.\n */\nlibrary Exec {\n\n    function call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function staticcall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal view returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function delegateCall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    // get returned data from last call or calldelegate\n    function getReturnData(uint256 maxLen) internal pure returns (bytes memory returnData) {\n        assembly (\"memory-safe\") {\n            let len := returndatasize()\n            if gt(len, maxLen) {\n                len := maxLen\n            }\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, add(len, 0x20)))\n            mstore(ptr, len)\n            returndatacopy(add(ptr, 0x20), 0, len)\n            returnData := ptr\n        }\n    }\n\n    // revert with explicit byte array (probably reverted info from call)\n    function revertWithData(bytes memory returnData) internal pure {\n        assembly (\"memory-safe\") {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function callAndRevert(address to, bytes memory data, uint256 maxLen) internal {\n        bool success = call(to,0,data,gasleft());\n        if (!success) {\n            revertWithData(getReturnData(maxLen));\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}