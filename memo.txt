
ðŸ˜ˆ[ì˜¤ëŠ˜ì •ë¦¬]ðŸ¹ðŸ¦ðŸ˜ˆðŸ¹ðŸ¦ðŸ˜ˆðŸ¹ðŸ¦ðŸ˜ˆðŸ¹ðŸ¦ðŸ˜ˆðŸ¹ðŸ¦ðŸ˜ˆðŸ¹ðŸ¦ðŸ˜ˆðŸ¹ðŸ¦ðŸ˜ˆðŸ¹ðŸ¦ðŸ˜ˆðŸ¹ðŸ¦


yarn hardhat compile --network zkSyncTestnet
Passing the --network flag we make sure Hardhat will use the zksolc compiler (or zkvyper).


ðŸŒŸ[ì •ë¦¬]ðŸ“ðŸ¦‹âš¾ï¸ðŸ¥ŽðŸðŸ³ðŸ€ðŸŒ¼ðŸŒ¸ðŸ†ðŸœðŸ˜ˆðŸ¹ðŸ¦ðŸŒŸðŸ”¹â™¦ï¸âš¡ï¸ðŸ’¥ðŸŒˆðŸ”¥âš¾ï¸ðŸ¶ðŸ¦„â˜•ï¸ðŸš˜ðŸ”´
* ìˆœì„œ
- íŒ…ì»¤ë²¨ì—ì„œ ì‹œìž‘, íŒ…ì»¤ë²¨ ë¶„ì„ ë° í•´ë²•: [], 1), a) ë¡œ êµ¬íš ë¶„ë¥˜
- í”¼í„°íŒ¬ì€ ì—°ìŠµìž¥
- ë°ì´í„° êµ¬ì¡°ì™€ ë³¸ê²Œìž„ì€ ì°°ë¦¬ ì •ë¦¬
- ë…¸íŠ¸ í•œìž¥ì— ì •ë¦¬
- ì‹¤ì œ ë°ì´í„°ë¥¼ ê°€ì§€ê³  ì•Œê³ ë¦¬ì¦˜ ë§Œë“¤ê¸° & ë‹¨ê³„ë³„ë¡œ ì‹¤í–‰í•´ê°€ë©´ì„œ ë°ì´í„° í™•ì¸
- ê²½ìš°ì˜ ìˆ˜ë¥¼ ë‚˜ëˆ„ëŠ”ê²Œ ì¤‘ìš”.
- ë§‰í˜”ì„ë•Œ ë¹¨ë¦¬ ì§„í–‰í•  ìˆ˜ ìžˆëŠ” ëŠ¥ë ¥ í•„ìš”.
- aiê°€ ë§Œë“¤ì–´ì¤€ ì½”ë“œ í™•ì¸.
- í•­ìƒ ëª¨ë“  ì‹œìž‘ ì„¹ì…˜ì—ëŠ” == ë¥¼ ë‘”ë‹¤.

* ì „ëžµ
- 10ë¶„ ë¬¸ì œ ìˆ™ì§€ ë° ì•Œê³ ë¦¬ì¦˜ ë§Œë“¤ê¸° 
- ìž˜ í•œ ì‚¬ëžŒì˜ ì½”ë“œ ë°©ì‹ ë¶„ì„1: ë°ì´í„°ê°€ ì•„ë‹ˆë¼ ì†ì„±ì„ ì´ìš©í•¨. 
- mapì´ ì¸ë±ìŠ¤ë¥¼ ì“°ì§€ ì•Šì•„ì„œ ì¢‹ìŒ
- ì½”íŠ¸ë¥¼ ìµœì†Œí™”í•˜ëŠ” ë¶„ì„ ì‹œê°„ í•„ìš”

* ì£¼ì˜ ì 
- index ì‹¤ìˆ˜
- ìž‘ì€ ë”°ì˜´í‘œ ì“°ê¸°
- ì´ˆë°˜ì— ë‹¤ì–‘í•œ ê²½ìš°ì˜ ìˆ˜ë¥¼ ìž˜ ì •ë¦¬í•˜ë©´ì„œ í’€ì–´ê°€ì•¼í•¨.
- ì°°ë¦¬ì´ ë³€ìˆ˜ ì •ë¦¬(ì´ê±´ ë‚˜ì¤‘ì—ë„ ê¼­ ì‚¬ìš©)
- ì¤‘ìš”í•œ ìˆ˜ì •ì€ ë°±ì—…í•˜ê¸° (ê·¸ëƒ¥ copy í•´ ë†“ê¸° )
- ë³€ìˆ˜ë¥¼ ìµœì†Œí•œìœ¼ë¡œ í•˜ê¸°, ìµëª… í•¨ìˆ˜ë¡œ ì²˜ë¦¬ 
- í™”ë©´ê³¼ ì² ë¦¬ì™€ ì˜ì•  ë³€ìˆ˜ ì¼ì¹˜ì‹œí‚¤ê¸° 
- ì¤‘ê°„ì¤‘ê°„ì— ideaì—ì„œ chm í™œìš©í•˜ê¸° 

======
while (sumRiding(riding) > 0) {
    const index = riding.indexOf(0);
    var startingIndex = 0;
    if (index >= 0) {
        startingIndex = index + 1;
    }
    else {
        startingIndex = 0;
    }

    for (var i = startingIndex; i < startingIndex + n && i < length; i++) {
        if (i < length) {
            riding[i] = riding[i] - 1;
        }
    }
    answer++;
}

======
* ì°¸ê³  ì½”ë“œ ì •ë¦¬
let inoutMap = new Map();// ì´ëŸ° ë§µë„ ìžˆë„¤.
for (const [start, end] of edges) // for ë¬¸ì€ ì´ë ‡ê²Œ
of Object.entries(map) // mapì€ ì´ë ‡ê²Œ 
array.splice(indexToRemove, 1); // arryì—ì„œ ì œê±° 
groups[i].indexOf(node[0]) >= 0 && indices.push(i); // if ëŒ€ì‹ 
let uniqueArray = [...new Set(array)]; // unique array
map[start] = map[start] ?? [0, 0] // ì—†ìœ¼ë©´ ì¶”ê°€í•˜ê¸° 

var graph = new Array(max + 1).fill(null).map(() => [[], []]);
Array.from({ length: n }, (_, i) => i)
combo.push(arr[i]); and combo.pop();
bestCombination.map(index => index + 1).sort((a, b) => a - b);

const friend = gift.split(" ");
data[friend[0]] ??= {};
data[friend[0]][friend[1]] ??= 0;
data[friend[0]][friend[1]] += 1;


// Map
var sortedGroups = [];
for (var i = 0; i < groups.length; i++) {
    var temp = groups[i];
    const uniqueArray = temp.filter((item, index) => temp.indexOf(item) === index);
    var edgeCount = 0;
    for (var j = 0; j < edges.length; j++) {
        if ((uniqueArray.indexOf(edges[j][0]) >= 0 || uniqueArray.indexOf(edges[j][1]) >= 0) && edges[j].indexOf(connecting) == -1) {
            edgeCount++;
        }
        // console.log("uniqueArray", uniqueArray, "edges[i]", edges[i], "edgeCount", edgeCount);
    }
    sortedGroups.push({ 0: uniqueArray, 1: edgeCount });
}
// console.log("sortedGroups", sortedGroups);

answer[0] = connecting;
for (var i = 0; i < sortedGroups.length; i++) {
    if (sortedGroups[i][0].length == sortedGroups[i][1]) {
        answer[1] += 1;
    }
    else if (sortedGroups[i][0].length - 1 == sortedGroups[i][1]) {
        answer[2] += 1;
    }
    else {
        answer[3] += 1;
    }
}


        
